{"message":"unused import: `EthernetPacket`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\network_handle.rs","byte_start":221,"byte_end":235,"line_start":7,"line_end":7,"column_start":42,"column_end":56,"is_primary":true,"text":[{"text":"use pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};","highlight_start":42,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\network_handle.rs","byte_start":219,"byte_end":235,"line_start":7,"line_end":7,"column_start":40,"column_end":56,"is_primary":true,"text":[{"text":"use pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};","highlight_start":40,"highlight_end":56}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `EthernetPacket`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network_handle.rs:7:42\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `Protocol`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\network_handle.rs","byte_start":393,"byte_end":401,"line_start":10,"line_end":10,"column_start":54,"column_end":62,"is_primary":true,"text":[{"text":"use crate::packet_handle::{Filter, FilteredProtocol, Protocol};","highlight_start":54,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src\\network_handle.rs","byte_start":391,"byte_end":401,"line_start":10,"line_end":10,"column_start":52,"column_end":62,"is_primary":true,"text":[{"text":"use crate::packet_handle::{Filter, FilteredProtocol, Protocol};","highlight_start":52,"highlight_end":62}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `Protocol`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network_handle.rs:10:54\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse crate::packet_handle::{Filter, FilteredProtocol, Protocol};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^\u001b[0m\n\n"}
{"message":"unused imports: `EtherTypes`, `MutableEthernetPacket`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":550,"byte_end":560,"line_start":16,"line_end":16,"column_start":30,"column_end":40,"is_primary":true,"text":[{"text":"use pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};","highlight_start":30,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\main.rs","byte_start":578,"byte_end":599,"line_start":16,"line_end":16,"column_start":58,"column_end":79,"is_primary":true,"text":[{"text":"use pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};","highlight_start":58,"highlight_end":79}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":550,"byte_end":562,"line_start":16,"line_end":16,"column_start":30,"column_end":42,"is_primary":true,"text":[{"text":"use pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};","highlight_start":30,"highlight_end":42}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src\\main.rs","byte_start":576,"byte_end":599,"line_start":16,"line_end":16,"column_start":56,"column_end":79,"is_primary":true,"text":[{"text":"use pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};","highlight_start":56,"highlight_end":79}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused imports: `EtherTypes`, `MutableEthernetPacket`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:16:30\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse pnet::packet::ethernet::{EtherTypes, EthernetPacket, MutableEthernetPacket};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^\u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `pnet::packet::ipv4::Ipv4Packet`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":607,"byte_end":637,"line_start":17,"line_end":17,"column_start":5,"column_end":35,"is_primary":true,"text":[{"text":"use pnet::packet::ipv4::Ipv4Packet;","highlight_start":5,"highlight_end":35}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":603,"byte_end":638,"line_start":17,"line_end":17,"column_start":1,"column_end":36,"is_primary":true,"text":[{"text":"use pnet::packet::ipv4::Ipv4Packet;","highlight_start":1,"highlight_end":36}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `pnet::packet::ipv4::Ipv4Packet`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:17:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse pnet::packet::ipv4::Ipv4Packet;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"unused import: `pnet::util::MacAddr`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\main.rs","byte_start":644,"byte_end":663,"line_start":18,"line_end":18,"column_start":5,"column_end":24,"is_primary":true,"text":[{"text":"use pnet::util::MacAddr;","highlight_start":5,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\main.rs","byte_start":640,"byte_end":664,"line_start":18,"line_end":18,"column_start":1,"column_end":25,"is_primary":true,"text":[{"text":"use pnet::util::MacAddr;","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `pnet::util::MacAddr`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\main.rs:18:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse pnet::util::MacAddr;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"`FilteredProtocol` is not an iterator","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\packet_handle.rs","byte_start":5953,"byte_end":5978,"line_start":235,"line_end":235,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"pub enum FilteredProtocol {","highlight_start":1,"highlight_end":26}],"label":"variant or associated item `into_iter` not found here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\network_handle.rs","byte_start":18796,"byte_end":18805,"line_start":461,"line_end":461,"column_start":45,"column_end":54,"is_primary":true,"text":[{"text":"                for ft in FilteredProtocol::into_iter(){","highlight_start":45,"highlight_end":54}],"label":"`FilteredProtocol` is not an iterator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\packet_handle.rs","byte_start":5953,"byte_end":5978,"line_start":235,"line_end":235,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"pub enum FilteredProtocol {","highlight_start":1,"highlight_end":26}],"label":"doesn't satisfy `FilteredProtocol: IntoIterator`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\packet_handle.rs","byte_start":5953,"byte_end":5978,"line_start":235,"line_end":235,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"pub enum FilteredProtocol {","highlight_start":1,"highlight_end":26}],"label":"doesn't satisfy `FilteredProtocol: Iterator`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`FilteredProtocol: Iterator`\nwhich is required by `FilteredProtocol: IntoIterator`\n`&FilteredProtocol: Iterator`\nwhich is required by `&FilteredProtocol: IntoIterator`\n`&mut FilteredProtocol: Iterator`\nwhich is required by `&mut FilteredProtocol: IntoIterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following trait must be implemented","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\patri\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\iterator.rs","byte_start":2688,"byte_end":123692,"line_start":66,"line_end":3774,"column_start":1,"column_end":2,"is_primary":true,"text":[{"text":"pub trait Iterator {","highlight_start":1,"highlight_end":21},{"text":"    /// The type of the elements being iterated over.","highlight_start":1,"highlight_end":54},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    type Item;","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Advances the iterator and returns the next value.","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Returns [`None`] when iteration is finished. Individual iterator","highlight_start":1,"highlight_end":73},{"text":"    /// implementations may choose to resume iteration, and so calling `next()`","highlight_start":1,"highlight_end":80},{"text":"    /// again may or may not eventually start returning [`Some(Item)`] again at some","highlight_start":1,"highlight_end":85},{"text":"    /// point.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Some(Item)`]: Some","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // A call to next() returns the next value...","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!(Some(&1), iter.next());","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(Some(&2), iter.next());","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(Some(&3), iter.next());","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // ... and then None once it's over.","highlight_start":1,"highlight_end":45},{"text":"    /// assert_eq!(None, iter.next());","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // More calls may or may not return `None`. Here, they always will.","highlight_start":1,"highlight_end":76},{"text":"    /// assert_eq!(None, iter.next());","highlight_start":1,"highlight_end":39},{"text":"    /// assert_eq!(None, iter.next());","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[lang = \"next\"]","highlight_start":1,"highlight_end":21},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn next(&mut self) -> Option<Self::Item>;","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the bounds on the remaining length of the iterator.","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Specifically, `size_hint()` returns a tuple where the first element","highlight_start":1,"highlight_end":76},{"text":"    /// is the lower bound, and the second element is the upper bound.","highlight_start":1,"highlight_end":71},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.","highlight_start":1,"highlight_end":92},{"text":"    /// A [`None`] here means that either there is no known upper bound, or the","highlight_start":1,"highlight_end":80},{"text":"    /// upper bound is larger than [`usize`].","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Implementation notes","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// It is not enforced that an iterator implementation yields the declared","highlight_start":1,"highlight_end":79},{"text":"    /// number of elements. A buggy iterator may yield less than the lower bound","highlight_start":1,"highlight_end":81},{"text":"    /// or more than the upper bound of elements.","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `size_hint()` is primarily intended to be used for optimizations such as","highlight_start":1,"highlight_end":81},{"text":"    /// reserving space for the elements of the iterator, but must not be","highlight_start":1,"highlight_end":74},{"text":"    /// trusted to e.g., omit bounds checks in unsafe code. An incorrect","highlight_start":1,"highlight_end":73},{"text":"    /// implementation of `size_hint()` should not lead to memory safety","highlight_start":1,"highlight_end":73},{"text":"    /// violations.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// That said, the implementation should provide a correct estimation,","highlight_start":1,"highlight_end":75},{"text":"    /// because otherwise it would be a violation of the trait's protocol.","highlight_start":1,"highlight_end":75},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The default implementation returns <code>(0, [None])</code> which is correct for any","highlight_start":1,"highlight_end":93},{"text":"    /// iterator.","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// let iter = a.iter();","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!((3, Some(3)), iter.size_hint());","highlight_start":1,"highlight_end":52},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// A more complex example:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// // The even numbers in the range of zero to nine.","highlight_start":1,"highlight_end":58},{"text":"    /// let iter = (0..10).filter(|x| x % 2 == 0);","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // We might iterate from zero to ten times. Knowing that it's five","highlight_start":1,"highlight_end":75},{"text":"    /// // exactly wouldn't be possible without executing filter().","highlight_start":1,"highlight_end":68},{"text":"    /// assert_eq!((0, Some(10)), iter.size_hint());","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Let's add five more numbers with chain()","highlight_start":1,"highlight_end":52},{"text":"    /// let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // now both bounds are increased by five","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!((5, Some(15)), iter.size_hint());","highlight_start":1,"highlight_end":53},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Returning `None` for an upper bound:","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// // an infinite iterator has no upper bound","highlight_start":1,"highlight_end":51},{"text":"    /// // and the maximum possible lower bound","highlight_start":1,"highlight_end":48},{"text":"    /// let iter = 0..;","highlight_start":1,"highlight_end":24},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!((usize::MAX, None), iter.size_hint());","highlight_start":1,"highlight_end":58},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn size_hint(&self) -> (usize, Option<usize>) {","highlight_start":1,"highlight_end":52},{"text":"        (0, None)","highlight_start":1,"highlight_end":18},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Consumes the iterator, counting the number of iterations and returning it.","highlight_start":1,"highlight_end":83},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method will call [`next`] repeatedly until [`None`] is encountered,","highlight_start":1,"highlight_end":81},{"text":"    /// returning the number of times it saw [`Some`]. Note that [`next`] has to be","highlight_start":1,"highlight_end":84},{"text":"    /// called at least once even if the iterator does not have any elements.","highlight_start":1,"highlight_end":78},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`next`]: Iterator::next","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Overflow Behavior","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The method does no guarding against overflows, so counting elements of","highlight_start":1,"highlight_end":79},{"text":"    /// an iterator with more than [`usize::MAX`] elements either produces the","highlight_start":1,"highlight_end":79},{"text":"    /// wrong result or panics. If debug assertions are enabled, a panic is","highlight_start":1,"highlight_end":76},{"text":"    /// guaranteed.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Panics","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This function might panic if the iterator has more than [`usize::MAX`]","highlight_start":1,"highlight_end":79},{"text":"    /// elements.","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// assert_eq!(a.iter().count(), 3);","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [1, 2, 3, 4, 5];","highlight_start":1,"highlight_end":33},{"text":"    /// assert_eq!(a.iter().count(), 5);","highlight_start":1,"highlight_end":41},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn count(self) -> usize","highlight_start":1,"highlight_end":28},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.fold(","highlight_start":1,"highlight_end":19},{"text":"            0,","highlight_start":1,"highlight_end":15},{"text":"            #[rustc_inherit_overflow_checks]","highlight_start":1,"highlight_end":45},{"text":"            |count, _| count + 1,","highlight_start":1,"highlight_end":34},{"text":"        )","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Consumes the iterator, returning the last element.","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method will evaluate the iterator until it returns [`None`]. While","highlight_start":1,"highlight_end":80},{"text":"    /// doing so, it keeps track of the current element. After [`None`] is","highlight_start":1,"highlight_end":75},{"text":"    /// returned, `last()` will then return the last element it saw.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// assert_eq!(a.iter().last(), Some(&3));","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [1, 2, 3, 4, 5];","highlight_start":1,"highlight_end":33},{"text":"    /// assert_eq!(a.iter().last(), Some(&5));","highlight_start":1,"highlight_end":47},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn last(self) -> Option<Self::Item>","highlight_start":1,"highlight_end":40},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn some<T>(_: Option<T>, x: T) -> Option<T> {","highlight_start":1,"highlight_end":54},{"text":"            Some(x)","highlight_start":1,"highlight_end":20},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.fold(None, some)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Advances the iterator by `n` elements.","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method will eagerly skip `n` elements by calling [`next`] up to `n`","highlight_start":1,"highlight_end":81},{"text":"    /// times until [`None`] is encountered.","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `advance_by(n)` will return [`Ok(())`][Ok] if the iterator successfully advances by","highlight_start":1,"highlight_end":92},{"text":"    /// `n` elements, or [`Err(k)`][Err] if [`None`] is encountered, where `k` is the number","highlight_start":1,"highlight_end":93},{"text":"    /// of elements the iterator is advanced by before running out of elements (i.e. the","highlight_start":1,"highlight_end":89},{"text":"    /// length of the iterator). Note that `k` is always less than `n`.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Calling `advance_by(0)` can do meaningful work, for example [`Flatten`]","highlight_start":1,"highlight_end":80},{"text":"    /// can advance its outer iterator until it finds an inner iterator that is not empty, which","highlight_start":1,"highlight_end":97},{"text":"    /// then often allows it to return a more accurate `size_hint()` than in its initial state.","highlight_start":1,"highlight_end":96},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Flatten`]: crate::iter::Flatten","highlight_start":1,"highlight_end":42},{"text":"    /// [`next`]: Iterator::next","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_advance_by)]","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [1, 2, 3, 4];","highlight_start":1,"highlight_end":30},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.advance_by(2), Ok(()));","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.advance_by(0), Ok(()));","highlight_start":1,"highlight_end":48},{"text":"    /// assert_eq!(iter.advance_by(100), Err(1)); // only `&4` was skipped","highlight_start":1,"highlight_end":75},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"77404\")]","highlight_start":1,"highlight_end":89},{"text":"    fn advance_by(&mut self, n: usize) -> Result<(), usize> {","highlight_start":1,"highlight_end":62},{"text":"        for i in 0..n {","highlight_start":1,"highlight_end":24},{"text":"            self.next().ok_or(i)?;","highlight_start":1,"highlight_end":35},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        Ok(())","highlight_start":1,"highlight_end":15},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the `n`th element of the iterator.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Like most indexing operations, the count starts from zero, so `nth(0)`","highlight_start":1,"highlight_end":79},{"text":"    /// returns the first value, `nth(1)` the second, and so on.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that all preceding elements, as well as the returned element, will be","highlight_start":1,"highlight_end":83},{"text":"    /// consumed from the iterator. That means that the preceding elements will be","highlight_start":1,"highlight_end":83},{"text":"    /// discarded, and also that calling `nth(0)` multiple times on the same iterator","highlight_start":1,"highlight_end":86},{"text":"    /// will return different elements.","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `nth()` will return [`None`] if `n` is greater than or equal to the length of the","highlight_start":1,"highlight_end":90},{"text":"    /// iterator.","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// assert_eq!(a.iter().nth(1), Some(&2));","highlight_start":1,"highlight_end":47},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Calling `nth()` multiple times doesn't rewind the iterator:","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.nth(1), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.nth(1), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Returning `None` if there are less than `n + 1` elements:","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// assert_eq!(a.iter().nth(10), None);","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn nth(&mut self, n: usize) -> Option<Self::Item> {","highlight_start":1,"highlight_end":56},{"text":"        self.advance_by(n).ok()?;","highlight_start":1,"highlight_end":34},{"text":"        self.next()","highlight_start":1,"highlight_end":20},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator starting at the same point, but stepping by","highlight_start":1,"highlight_end":72},{"text":"    /// the given amount at each iteration.","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note 1: The first element of the iterator will always be returned,","highlight_start":1,"highlight_end":75},{"text":"    /// regardless of the step given.","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note 2: The time at which ignored elements are pulled is not fixed.","highlight_start":1,"highlight_end":76},{"text":"    /// `StepBy` behaves like the sequence `self.next()`, `self.nth(step-1)`,","highlight_start":1,"highlight_end":78},{"text":"    /// `self.nth(step-1)`, â€¦, but is also free to behave like the sequence","highlight_start":1,"highlight_end":76},{"text":"    /// `advance_n_and_return_first(&mut self, step)`,","highlight_start":1,"highlight_end":55},{"text":"    /// `advance_n_and_return_first(&mut self, step)`, â€¦","highlight_start":1,"highlight_end":57},{"text":"    /// Which way is used may change for some iterators for performance reasons.","highlight_start":1,"highlight_end":81},{"text":"    /// The second way will advance the iterator earlier and may consume more items.","highlight_start":1,"highlight_end":85},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `advance_n_and_return_first` is the equivalent of:","highlight_start":1,"highlight_end":59},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// fn advance_n_and_return_first<I>(iter: &mut I, n: usize) -> Option<I::Item>","highlight_start":1,"highlight_end":84},{"text":"    /// where","highlight_start":1,"highlight_end":14},{"text":"    ///     I: Iterator,","highlight_start":1,"highlight_end":25},{"text":"    /// {","highlight_start":1,"highlight_end":10},{"text":"    ///     let next = iter.next();","highlight_start":1,"highlight_end":36},{"text":"    ///     if n > 1 {","highlight_start":1,"highlight_end":23},{"text":"    ///         iter.nth(n - 2);","highlight_start":1,"highlight_end":33},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    ///     next","highlight_start":1,"highlight_end":17},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Panics","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The method will panic if the given step is `0`.","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [0, 1, 2, 3, 4, 5];","highlight_start":1,"highlight_end":36},{"text":"    /// let mut iter = a.iter().step_by(2);","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&0));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&4));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]","highlight_start":1,"highlight_end":62},{"text":"    fn step_by(self, step: usize) -> StepBy<Self>","highlight_start":1,"highlight_end":50},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        StepBy::new(self, step)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Takes two iterators and creates a new iterator over both in sequence.","highlight_start":1,"highlight_end":78},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `chain()` will return a new iterator which will first iterate over","highlight_start":1,"highlight_end":75},{"text":"    /// values from the first iterator and then over values from the second","highlight_start":1,"highlight_end":76},{"text":"    /// iterator.","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In other words, it links two iterators together, in a chain. ðŸ”—","highlight_start":1,"highlight_end":71},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`once`] is commonly used to adapt a single value into a chain of","highlight_start":1,"highlight_end":74},{"text":"    /// other kinds of iteration.","highlight_start":1,"highlight_end":34},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a1 = [1, 2, 3];","highlight_start":1,"highlight_end":28},{"text":"    /// let a2 = [4, 5, 6];","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a1.iter().chain(a2.iter());","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&4));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&5));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&6));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Since the argument to `chain()` uses [`IntoIterator`], we can pass","highlight_start":1,"highlight_end":75},{"text":"    /// anything that can be converted into an [`Iterator`], not just an","highlight_start":1,"highlight_end":73},{"text":"    /// [`Iterator`] itself. For example, slices (`&[T]`) implement","highlight_start":1,"highlight_end":68},{"text":"    /// [`IntoIterator`], and so can be passed to `chain()` directly:","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let s1 = &[1, 2, 3];","highlight_start":1,"highlight_end":29},{"text":"    /// let s2 = &[4, 5, 6];","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = s1.iter().chain(s2);","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&4));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&5));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&6));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If you work with Windows API, you may wish to convert [`OsStr`] to `Vec<u16>`:","highlight_start":1,"highlight_end":87},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #[cfg(windows)]","highlight_start":1,"highlight_end":24},{"text":"    /// fn os_str_to_utf16(s: &std::ffi::OsStr) -> Vec<u16> {","highlight_start":1,"highlight_end":62},{"text":"    ///     use std::os::windows::ffi::OsStrExt;","highlight_start":1,"highlight_end":49},{"text":"    ///     s.encode_wide().chain(std::iter::once(0)).collect()","highlight_start":1,"highlight_end":64},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`once`]: crate::iter::once","highlight_start":1,"highlight_end":36},{"text":"    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html","highlight_start":1,"highlight_end":51},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn chain<U>(self, other: U) -> Chain<Self, U::IntoIter>","highlight_start":1,"highlight_end":60},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        U: IntoIterator<Item = Self::Item>,","highlight_start":1,"highlight_end":44},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Chain::new(self, other.into_iter())","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// 'Zips up' two iterators into a single iterator of pairs.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `zip()` returns a new iterator that will iterate over two other","highlight_start":1,"highlight_end":72},{"text":"    /// iterators, returning a tuple where the first element comes from the","highlight_start":1,"highlight_end":76},{"text":"    /// first iterator, and the second element comes from the second iterator.","highlight_start":1,"highlight_end":79},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In other words, it zips two iterators together, into a single one.","highlight_start":1,"highlight_end":75},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If either iterator returns [`None`], [`next`] from the zipped iterator","highlight_start":1,"highlight_end":79},{"text":"    /// will return [`None`].","highlight_start":1,"highlight_end":30},{"text":"    /// If the zipped iterator has no more elements to return then each further attempt to advance","highlight_start":1,"highlight_end":99},{"text":"    /// it will first try to advance the first iterator at most one time and if it still yielded an item","highlight_start":1,"highlight_end":105},{"text":"    /// try to advance the second iterator at most one time.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// To 'undo' the result of zipping up two iterators, see [`unzip`].","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`unzip`]: Iterator::unzip","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a1 = [1, 2, 3];","highlight_start":1,"highlight_end":28},{"text":"    /// let a2 = [4, 5, 6];","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a1.iter().zip(a2.iter());","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some((&1, &4)));","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!(iter.next(), Some((&2, &5)));","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!(iter.next(), Some((&3, &6)));","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Since the argument to `zip()` uses [`IntoIterator`], we can pass","highlight_start":1,"highlight_end":73},{"text":"    /// anything that can be converted into an [`Iterator`], not just an","highlight_start":1,"highlight_end":73},{"text":"    /// [`Iterator`] itself. For example, slices (`&[T]`) implement","highlight_start":1,"highlight_end":68},{"text":"    /// [`IntoIterator`], and so can be passed to `zip()` directly:","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let s1 = &[1, 2, 3];","highlight_start":1,"highlight_end":29},{"text":"    /// let s2 = &[4, 5, 6];","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = s1.iter().zip(s2);","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some((&1, &4)));","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!(iter.next(), Some((&2, &5)));","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!(iter.next(), Some((&3, &6)));","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `zip()` is often used to zip an infinite iterator to a finite one.","highlight_start":1,"highlight_end":75},{"text":"    /// This works because the finite iterator will eventually return [`None`],","highlight_start":1,"highlight_end":80},{"text":"    /// ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate`]:","highlight_start":1,"highlight_end":83},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!((0, 'f'), enumerate[0]);","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!((0, 'f'), zipper[0]);","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!((1, 'o'), enumerate[1]);","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!((1, 'o'), zipper[1]);","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!((2, 'o'), enumerate[2]);","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!((2, 'o'), zipper[2]);","highlight_start":1,"highlight_end":41},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If both iterators have roughly equivalent syntax, it may be more readable to use [`zip`]:","highlight_start":1,"highlight_end":98},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use std::iter::zip;","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// let b = [2, 3, 4];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut zipped = zip(","highlight_start":1,"highlight_end":30},{"text":"    ///     a.into_iter().map(|x| x * 2).skip(1),","highlight_start":1,"highlight_end":50},{"text":"    ///     b.into_iter().map(|x| x * 2).skip(1),","highlight_start":1,"highlight_end":50},{"text":"    /// );","highlight_start":1,"highlight_end":11},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(zipped.next(), Some((4, 6)));","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!(zipped.next(), Some((6, 8)));","highlight_start":1,"highlight_end":49},{"text":"    /// assert_eq!(zipped.next(), None);","highlight_start":1,"highlight_end":41},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// compared to:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// # let a = [1, 2, 3];","highlight_start":1,"highlight_end":29},{"text":"    /// # let b = [2, 3, 4];","highlight_start":1,"highlight_end":29},{"text":"    /// #","highlight_start":1,"highlight_end":10},{"text":"    /// let mut zipped = a","highlight_start":1,"highlight_end":27},{"text":"    ///     .into_iter()","highlight_start":1,"highlight_end":25},{"text":"    ///     .map(|x| x * 2)","highlight_start":1,"highlight_end":28},{"text":"    ///     .skip(1)","highlight_start":1,"highlight_end":21},{"text":"    ///     .zip(b.into_iter().map(|x| x * 2).skip(1));","highlight_start":1,"highlight_end":56},{"text":"    /// #","highlight_start":1,"highlight_end":10},{"text":"    /// # assert_eq!(zipped.next(), Some((4, 6)));","highlight_start":1,"highlight_end":51},{"text":"    /// # assert_eq!(zipped.next(), Some((6, 8)));","highlight_start":1,"highlight_end":51},{"text":"    /// # assert_eq!(zipped.next(), None);","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`enumerate`]: Iterator::enumerate","highlight_start":1,"highlight_end":43},{"text":"    /// [`next`]: Iterator::next","highlight_start":1,"highlight_end":33},{"text":"    /// [`zip`]: crate::iter::zip","highlight_start":1,"highlight_end":34},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>","highlight_start":1,"highlight_end":56},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        U: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Zip::new(self, other.into_iter())","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates a new iterator which places a copy of `separator` between adjacent","highlight_start":1,"highlight_end":83},{"text":"    /// items of the original iterator.","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In case `separator` does not implement [`Clone`] or needs to be","highlight_start":1,"highlight_end":72},{"text":"    /// computed every time, use [`intersperse_with`].","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_intersperse)]","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut a = [0, 1, 2].iter().intersperse(&100);","highlight_start":1,"highlight_end":56},{"text":"    /// assert_eq!(a.next(), Some(&0));   // The first element from `a`.","highlight_start":1,"highlight_end":73},{"text":"    /// assert_eq!(a.next(), Some(&100)); // The separator.","highlight_start":1,"highlight_end":60},{"text":"    /// assert_eq!(a.next(), Some(&1));   // The next element from `a`.","highlight_start":1,"highlight_end":72},{"text":"    /// assert_eq!(a.next(), Some(&100)); // The separator.","highlight_start":1,"highlight_end":60},{"text":"    /// assert_eq!(a.next(), Some(&2));   // The last element from `a`.","highlight_start":1,"highlight_end":72},{"text":"    /// assert_eq!(a.next(), None);       // The iterator is finished.","highlight_start":1,"highlight_end":71},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `intersperse` can be very useful to join an iterator's items using a common element:","highlight_start":1,"highlight_end":93},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_intersperse)]","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let hello = [\"Hello\", \"World\", \"!\"].iter().copied().intersperse(\" \").collect::<String>();","highlight_start":1,"highlight_end":98},{"text":"    /// assert_eq!(hello, \"Hello World !\");","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Clone`]: crate::clone::Clone","highlight_start":1,"highlight_end":39},{"text":"    /// [`intersperse_with`]: Iterator::intersperse_with","highlight_start":1,"highlight_end":57},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]","highlight_start":1,"highlight_end":90},{"text":"    fn intersperse(self, separator: Self::Item) -> Intersperse<Self>","highlight_start":1,"highlight_end":69},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        Self::Item: Clone,","highlight_start":1,"highlight_end":27},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Intersperse::new(self, separator)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates a new iterator which places an item generated by `separator`","highlight_start":1,"highlight_end":77},{"text":"    /// between adjacent items of the original iterator.","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The closure will be called exactly once each time an item is placed","highlight_start":1,"highlight_end":76},{"text":"    /// between two adjacent items from the underlying iterator; specifically,","highlight_start":1,"highlight_end":79},{"text":"    /// the closure is not called if the underlying iterator yields less than","highlight_start":1,"highlight_end":78},{"text":"    /// two items and after the last item is yielded.","highlight_start":1,"highlight_end":54},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If the iterator's item implements [`Clone`], it may be easier to use","highlight_start":1,"highlight_end":77},{"text":"    /// [`intersperse`].","highlight_start":1,"highlight_end":25},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_intersperse)]","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// #[derive(PartialEq, Debug)]","highlight_start":1,"highlight_end":36},{"text":"    /// struct NotClone(usize);","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let v = [NotClone(0), NotClone(1), NotClone(2)];","highlight_start":1,"highlight_end":57},{"text":"    /// let mut it = v.into_iter().intersperse_with(|| NotClone(99));","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(it.next(), Some(NotClone(0)));  // The first element from `v`.","highlight_start":1,"highlight_end":82},{"text":"    /// assert_eq!(it.next(), Some(NotClone(99))); // The separator.","highlight_start":1,"highlight_end":69},{"text":"    /// assert_eq!(it.next(), Some(NotClone(1)));  // The next element from `v`.","highlight_start":1,"highlight_end":81},{"text":"    /// assert_eq!(it.next(), Some(NotClone(99))); // The separator.","highlight_start":1,"highlight_end":69},{"text":"    /// assert_eq!(it.next(), Some(NotClone(2)));  // The last element from from `v`.","highlight_start":1,"highlight_end":86},{"text":"    /// assert_eq!(it.next(), None);               // The iterator is finished.","highlight_start":1,"highlight_end":80},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `intersperse_with` can be used in situations where the separator needs","highlight_start":1,"highlight_end":79},{"text":"    /// to be computed:","highlight_start":1,"highlight_end":24},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_intersperse)]","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let src = [\"Hello\", \"to\", \"all\", \"people\", \"!!\"].iter().copied();","highlight_start":1,"highlight_end":74},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // The closure mutably borrows its context to generate an item.","highlight_start":1,"highlight_end":72},{"text":"    /// let mut happy_emojis = [\" â¤ï¸ \", \" ðŸ˜€ \"].iter().copied();","highlight_start":1,"highlight_end":64},{"text":"    /// let separator = || happy_emojis.next().unwrap_or(\" ðŸ¦€ \");","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result = src.intersperse_with(separator).collect::<String>();","highlight_start":1,"highlight_end":74},{"text":"    /// assert_eq!(result, \"Hello â¤ï¸ to ðŸ˜€ all ðŸ¦€ people ðŸ¦€ !!\");","highlight_start":1,"highlight_end":63},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// [`Clone`]: crate::clone::Clone","highlight_start":1,"highlight_end":39},{"text":"    /// [`intersperse`]: Iterator::intersperse","highlight_start":1,"highlight_end":47},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]","highlight_start":1,"highlight_end":90},{"text":"    fn intersperse_with<G>(self, separator: G) -> IntersperseWith<Self, G>","highlight_start":1,"highlight_end":75},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        G: FnMut() -> Self::Item,","highlight_start":1,"highlight_end":34},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        IntersperseWith::new(self, separator)","highlight_start":1,"highlight_end":46},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Takes a closure and creates an iterator which calls that closure on each","highlight_start":1,"highlight_end":81},{"text":"    /// element.","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `map()` transforms one iterator into another, by means of its argument:","highlight_start":1,"highlight_end":80},{"text":"    /// something that implements [`FnMut`]. It produces a new iterator which","highlight_start":1,"highlight_end":78},{"text":"    /// calls this closure on each element of the original iterator.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If you are good at thinking in types, you can think of `map()` like this:","highlight_start":1,"highlight_end":82},{"text":"    /// If you have an iterator that gives you elements of some type `A`, and","highlight_start":1,"highlight_end":78},{"text":"    /// you want an iterator of some other type `B`, you can use `map()`,","highlight_start":1,"highlight_end":74},{"text":"    /// passing a closure that takes an `A` and returns a `B`.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `map()` is conceptually similar to a [`for`] loop. However, as `map()` is","highlight_start":1,"highlight_end":82},{"text":"    /// lazy, it is best used when you're already working with other iterators.","highlight_start":1,"highlight_end":80},{"text":"    /// If you're doing some sort of looping for a side effect, it's considered","highlight_start":1,"highlight_end":80},{"text":"    /// more idiomatic to use [`for`] than `map()`.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for","highlight_start":1,"highlight_end":92},{"text":"    /// [`FnMut`]: crate::ops::FnMut","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().map(|x| 2 * x);","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(2));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), Some(4));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), Some(6));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If you're doing some sort of side effect, prefer [`for`] to `map()`:","highlight_start":1,"highlight_end":77},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// # #![allow(unused_must_use)]","highlight_start":1,"highlight_end":37},{"text":"    /// // don't do this:","highlight_start":1,"highlight_end":26},{"text":"    /// (0..5).map(|x| println!(\"{x}\"));","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // it won't even execute, as it is lazy. Rust will warn you about this.","highlight_start":1,"highlight_end":80},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Instead, use for:","highlight_start":1,"highlight_end":29},{"text":"    /// for x in 0..5 {","highlight_start":1,"highlight_end":24},{"text":"    ///     println!(\"{x}\");","highlight_start":1,"highlight_end":29},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn map<B, F>(self, f: F) -> Map<Self, F>","highlight_start":1,"highlight_end":45},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item) -> B,","highlight_start":1,"highlight_end":35},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Map::new(self, f)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Calls a closure on each element of an iterator.","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This is equivalent to using a [`for`] loop on the iterator, although","highlight_start":1,"highlight_end":77},{"text":"    /// `break` and `continue` are not possible from a closure. It's generally","highlight_start":1,"highlight_end":79},{"text":"    /// more idiomatic to use a `for` loop, but `for_each` may be more legible","highlight_start":1,"highlight_end":79},{"text":"    /// when processing items at the end of longer iterator chains. In some","highlight_start":1,"highlight_end":76},{"text":"    /// cases `for_each` may also be faster than a loop, because it will use","highlight_start":1,"highlight_end":77},{"text":"    /// internal iteration on adapters like `Chain`.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for","highlight_start":1,"highlight_end":92},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use std::sync::mpsc::channel;","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let (tx, rx) = channel();","highlight_start":1,"highlight_end":34},{"text":"    /// (0..5).map(|x| x * 2 + 1)","highlight_start":1,"highlight_end":34},{"text":"    ///       .for_each(move |x| tx.send(x).unwrap());","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let v: Vec<_> =  rx.iter().collect();","highlight_start":1,"highlight_end":46},{"text":"    /// assert_eq!(v, vec![1, 3, 5, 7, 9]);","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// For such a small example, a `for` loop may be cleaner, but `for_each`","highlight_start":1,"highlight_end":78},{"text":"    /// might be preferable to keep a functional style with longer iterators:","highlight_start":1,"highlight_end":78},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// (0..5).flat_map(|x| x * 100 .. x * 110)","highlight_start":1,"highlight_end":48},{"text":"    ///       .enumerate()","highlight_start":1,"highlight_end":27},{"text":"    ///       .filter(|&(i, x)| (i + x) % 3 == 0)","highlight_start":1,"highlight_end":50},{"text":"    ///       .for_each(|(i, x)| println!(\"{i}:{x}\"));","highlight_start":1,"highlight_end":55},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iterator_for_each\", since = \"1.21.0\")]","highlight_start":1,"highlight_end":63},{"text":"    fn for_each<F>(self, f: F)","highlight_start":1,"highlight_end":31},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item),","highlight_start":1,"highlight_end":30},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn call<T>(mut f: impl FnMut(T)) -> impl FnMut((), T) {","highlight_start":1,"highlight_end":64},{"text":"            move |(), item| f(item)","highlight_start":1,"highlight_end":36},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.fold((), call(f));","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator which uses a closure to determine if an element","highlight_start":1,"highlight_end":76},{"text":"    /// should be yielded.","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Given an element the closure must return `true` or `false`. The returned","highlight_start":1,"highlight_end":81},{"text":"    /// iterator will yield only the elements for which the closure returns","highlight_start":1,"highlight_end":76},{"text":"    /// true.","highlight_start":1,"highlight_end":14},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [0i32, 1, 2];","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().filter(|x| x.is_positive());","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Because the closure passed to `filter()` takes a reference, and many","highlight_start":1,"highlight_end":77},{"text":"    /// iterators iterate over references, this leads to a possibly confusing","highlight_start":1,"highlight_end":78},{"text":"    /// situation, where the type of the closure is a double reference:","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [0, 1, 2];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().filter(|x| **x > 1); // need two *s!","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// It's common to instead use destructuring on the argument to strip away","highlight_start":1,"highlight_end":79},{"text":"    /// one:","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [0, 1, 2];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().filter(|&x| *x > 1); // both & and *","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// or both:","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [0, 1, 2];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().filter(|&&x| x > 1); // two &s","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// of these layers.","highlight_start":1,"highlight_end":25},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that `iter.filter(f).next()` is equivalent to `iter.find(f)`.","highlight_start":1,"highlight_end":75},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn filter<P>(self, predicate: P) -> Filter<Self, P>","highlight_start":1,"highlight_end":56},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        P: FnMut(&Self::Item) -> bool,","highlight_start":1,"highlight_end":39},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Filter::new(self, predicate)","highlight_start":1,"highlight_end":37},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator that both filters and maps.","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The returned iterator yields only the `value`s for which the supplied","highlight_start":1,"highlight_end":78},{"text":"    /// closure returns `Some(value)`.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `filter_map` can be used to make chains of [`filter`] and [`map`] more","highlight_start":1,"highlight_end":79},{"text":"    /// concise. The example below shows how a `map().filter().map()` can be","highlight_start":1,"highlight_end":77},{"text":"    /// shortened to a single call to `filter_map`.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`filter`]: Iterator::filter","highlight_start":1,"highlight_end":37},{"text":"    /// [`map`]: Iterator::map","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"];","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().filter_map(|s| s.parse().ok());","highlight_start":1,"highlight_end":64},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(1));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), Some(5));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Here's the same example, but with [`filter`] and [`map`]:","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"];","highlight_start":1,"highlight_end":50},{"text":"    /// let mut iter = a.iter().map(|s| s.parse()).filter(|s| s.is_ok()).map(|s| s.unwrap());","highlight_start":1,"highlight_end":94},{"text":"    /// assert_eq!(iter.next(), Some(1));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), Some(5));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F>","highlight_start":1,"highlight_end":58},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item) -> Option<B>,","highlight_start":1,"highlight_end":43},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        FilterMap::new(self, f)","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator which gives the current iteration count as well as","highlight_start":1,"highlight_end":79},{"text":"    /// the next value.","highlight_start":1,"highlight_end":24},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The iterator returned yields pairs `(i, val)`, where `i` is the","highlight_start":1,"highlight_end":72},{"text":"    /// current index of iteration and `val` is the value returned by the","highlight_start":1,"highlight_end":74},{"text":"    /// iterator.","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `enumerate()` keeps its count as a [`usize`]. If you want to count by a","highlight_start":1,"highlight_end":80},{"text":"    /// different sized integer, the [`zip`] function provides similar","highlight_start":1,"highlight_end":71},{"text":"    /// functionality.","highlight_start":1,"highlight_end":23},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Overflow Behavior","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The method does no guarding against overflows, so enumerating more than","highlight_start":1,"highlight_end":80},{"text":"    /// [`usize::MAX`] elements either produces the wrong result or panics. If","highlight_start":1,"highlight_end":79},{"text":"    /// debug assertions are enabled, a panic is guaranteed.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Panics","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The returned iterator might panic if the to-be-returned index would","highlight_start":1,"highlight_end":76},{"text":"    /// overflow a [`usize`].","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`zip`]: Iterator::zip","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = ['a', 'b', 'c'];","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().enumerate();","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some((0, &'a')));","highlight_start":1,"highlight_end":50},{"text":"    /// assert_eq!(iter.next(), Some((1, &'b')));","highlight_start":1,"highlight_end":50},{"text":"    /// assert_eq!(iter.next(), Some((2, &'c')));","highlight_start":1,"highlight_end":50},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn enumerate(self) -> Enumerate<Self>","highlight_start":1,"highlight_end":42},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Enumerate::new(self)","highlight_start":1,"highlight_end":29},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator which can use the [`peek`] and [`peek_mut`] methods","highlight_start":1,"highlight_end":80},{"text":"    /// to look at the next element of the iterator without consuming it. See","highlight_start":1,"highlight_end":78},{"text":"    /// their documentation for more information.","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that the underlying iterator is still advanced when [`peek`] or","highlight_start":1,"highlight_end":77},{"text":"    /// [`peek_mut`] are called for the first time: In order to retrieve the","highlight_start":1,"highlight_end":77},{"text":"    /// next element, [`next`] is called on the underlying iterator, hence any","highlight_start":1,"highlight_end":79},{"text":"    /// side effects (i.e. anything other than fetching the next value) of","highlight_start":1,"highlight_end":75},{"text":"    /// the [`next`] method will occur.","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let xs = [1, 2, 3];","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = xs.iter().peekable();","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // peek() lets us see into the future","highlight_start":1,"highlight_end":46},{"text":"    /// assert_eq!(iter.peek(), Some(&&1));","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // we can peek() multiple times, the iterator won't advance","highlight_start":1,"highlight_end":68},{"text":"    /// assert_eq!(iter.peek(), Some(&&3));","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(iter.peek(), Some(&&3));","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // after the iterator is finished, so is peek()","highlight_start":1,"highlight_end":56},{"text":"    /// assert_eq!(iter.peek(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Using [`peek_mut`] to mutate the next item without advancing the","highlight_start":1,"highlight_end":73},{"text":"    /// iterator:","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let xs = [1, 2, 3];","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = xs.iter().peekable();","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // `peek_mut()` lets us see into the future","highlight_start":1,"highlight_end":52},{"text":"    /// assert_eq!(iter.peek_mut(), Some(&mut &1));","highlight_start":1,"highlight_end":52},{"text":"    /// assert_eq!(iter.peek_mut(), Some(&mut &1));","highlight_start":1,"highlight_end":52},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// if let Some(mut p) = iter.peek_mut() {","highlight_start":1,"highlight_end":47},{"text":"    ///     assert_eq!(*p, &2);","highlight_start":1,"highlight_end":32},{"text":"    ///     // put a value into the iterator","highlight_start":1,"highlight_end":45},{"text":"    ///     *p = &1000;","highlight_start":1,"highlight_end":24},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // The value reappears as the iterator continues","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!(iter.collect::<Vec<_>>(), vec![&1000, &3]);","highlight_start":1,"highlight_end":63},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// [`peek`]: Peekable::peek","highlight_start":1,"highlight_end":33},{"text":"    /// [`peek_mut`]: Peekable::peek_mut","highlight_start":1,"highlight_end":41},{"text":"    /// [`next`]: Iterator::next","highlight_start":1,"highlight_end":33},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn peekable(self) -> Peekable<Self>","highlight_start":1,"highlight_end":40},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Peekable::new(self)","highlight_start":1,"highlight_end":28},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator that [`skip`]s elements based on a predicate.","highlight_start":1,"highlight_end":74},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`skip`]: Iterator::skip","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `skip_while()` takes a closure as an argument. It will call this","highlight_start":1,"highlight_end":73},{"text":"    /// closure on each element of the iterator, and ignore elements","highlight_start":1,"highlight_end":69},{"text":"    /// until it returns `false`.","highlight_start":1,"highlight_end":34},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// After `false` is returned, `skip_while()`'s job is over, and the","highlight_start":1,"highlight_end":73},{"text":"    /// rest of the elements are yielded.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-1i32, 0, 1];","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().skip_while(|x| x.is_negative());","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&0));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Because the closure passed to `skip_while()` takes a reference, and many","highlight_start":1,"highlight_end":81},{"text":"    /// iterators iterate over references, this leads to a possibly confusing","highlight_start":1,"highlight_end":78},{"text":"    /// situation, where the type of the closure argument is a double reference:","highlight_start":1,"highlight_end":81},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-1, 0, 1];","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().skip_while(|x| **x < 0); // need two *s!","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&0));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Stopping after an initial `false`:","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-1, 0, 1, -2];","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().skip_while(|x| **x < 0);","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&0));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // while this would have been false, since we already got a false,","highlight_start":1,"highlight_end":75},{"text":"    /// // skip_while() isn't used any more","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(iter.next(), Some(&-2));","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[doc(alias = \"drop_while\")]","highlight_start":1,"highlight_end":33},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P>","highlight_start":1,"highlight_end":63},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        P: FnMut(&Self::Item) -> bool,","highlight_start":1,"highlight_end":39},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        SkipWhile::new(self, predicate)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator that yields elements based on a predicate.","highlight_start":1,"highlight_end":71},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `take_while()` takes a closure as an argument. It will call this","highlight_start":1,"highlight_end":73},{"text":"    /// closure on each element of the iterator, and yield elements","highlight_start":1,"highlight_end":68},{"text":"    /// while it returns `true`.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// After `false` is returned, `take_while()`'s job is over, and the","highlight_start":1,"highlight_end":73},{"text":"    /// rest of the elements are ignored.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-1i32, 0, 1];","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().take_while(|x| x.is_negative());","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&-1));","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Because the closure passed to `take_while()` takes a reference, and many","highlight_start":1,"highlight_end":81},{"text":"    /// iterators iterate over references, this leads to a possibly confusing","highlight_start":1,"highlight_end":78},{"text":"    /// situation, where the type of the closure is a double reference:","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-1, 0, 1];","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().take_while(|x| **x < 0); // need two *s!","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&-1));","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Stopping after an initial `false`:","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-1, 0, 1, -2];","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().take_while(|x| **x < 0);","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&-1));","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // We have more elements that are less than zero, but since we already","highlight_start":1,"highlight_end":79},{"text":"    /// // got a false, take_while() isn't used any more","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Because `take_while()` needs to look at the value in order to see if it","highlight_start":1,"highlight_end":80},{"text":"    /// should be included or not, consuming iterators will see that it is","highlight_start":1,"highlight_end":75},{"text":"    /// removed:","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3, 4];","highlight_start":1,"highlight_end":30},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result: Vec<i32> = iter.by_ref()","highlight_start":1,"highlight_end":45},{"text":"    ///                            .take_while(|n| **n != 3)","highlight_start":1,"highlight_end":61},{"text":"    ///                            .cloned()","highlight_start":1,"highlight_end":45},{"text":"    ///                            .collect();","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(result, &[1, 2]);","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result: Vec<i32> = iter.cloned().collect();","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(result, &[4]);","highlight_start":1,"highlight_end":34},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The `3` is no longer there, because it was consumed in order to see if","highlight_start":1,"highlight_end":79},{"text":"    /// the iteration should stop, but wasn't placed back into the iterator.","highlight_start":1,"highlight_end":77},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P>","highlight_start":1,"highlight_end":63},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        P: FnMut(&Self::Item) -> bool,","highlight_start":1,"highlight_end":39},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        TakeWhile::new(self, predicate)","highlight_start":1,"highlight_end":40},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator that both yields elements based on a predicate and maps.","highlight_start":1,"highlight_end":85},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `map_while()` takes a closure as an argument. It will call this","highlight_start":1,"highlight_end":72},{"text":"    /// closure on each element of the iterator, and yield elements","highlight_start":1,"highlight_end":68},{"text":"    /// while it returns [`Some(_)`][`Some`].","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-1i32, 4, 0, 1];","highlight_start":1,"highlight_end":34},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().map_while(|x| 16i32.checked_div(*x));","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(-16));","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(iter.next(), Some(4));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Here's the same example, but with [`take_while`] and [`map`]:","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`take_while`]: Iterator::take_while","highlight_start":1,"highlight_end":45},{"text":"    /// [`map`]: Iterator::map","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-1i32, 4, 0, 1];","highlight_start":1,"highlight_end":34},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter()","highlight_start":1,"highlight_end":32},{"text":"    ///                 .map(|x| 16i32.checked_div(*x))","highlight_start":1,"highlight_end":56},{"text":"    ///                 .take_while(|x| x.is_some())","highlight_start":1,"highlight_end":53},{"text":"    ///                 .map(|x| x.unwrap());","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(-16));","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(iter.next(), Some(4));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Stopping after an initial [`None`]:","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [0, 1, 2, -3, 4, 5, -6];","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let iter = a.iter().map_while(|x| u32::try_from(*x).ok());","highlight_start":1,"highlight_end":67},{"text":"    /// let vec = iter.collect::<Vec<_>>();","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // We have more elements which could fit in u32 (4, 5), but `map_while` returned `None` for `-3`","highlight_start":1,"highlight_end":105},{"text":"    /// // (as the `predicate` returned `None`) and `collect` stops at the first `None` encountered.","highlight_start":1,"highlight_end":101},{"text":"    /// assert_eq!(vec, vec![0, 1, 2]);","highlight_start":1,"highlight_end":40},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Because `map_while()` needs to look at the value in order to see if it","highlight_start":1,"highlight_end":79},{"text":"    /// should be included or not, consuming iterators will see that it is","highlight_start":1,"highlight_end":75},{"text":"    /// removed:","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, -3, 4];","highlight_start":1,"highlight_end":31},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result: Vec<u32> = iter.by_ref()","highlight_start":1,"highlight_end":45},{"text":"    ///                            .map_while(|n| u32::try_from(*n).ok())","highlight_start":1,"highlight_end":74},{"text":"    ///                            .collect();","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(result, &[1, 2]);","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result: Vec<i32> = iter.cloned().collect();","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(result, &[4]);","highlight_start":1,"highlight_end":34},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The `-3` is no longer there, because it was consumed in order to see if","highlight_start":1,"highlight_end":80},{"text":"    /// the iteration should stop, but wasn't placed back into the iterator.","highlight_start":1,"highlight_end":77},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that unlike [`take_while`] this iterator is **not** fused.","highlight_start":1,"highlight_end":72},{"text":"    /// It is also not specified what this iterator returns after the first [`None`] is returned.","highlight_start":1,"highlight_end":98},{"text":"    /// If you need fused iterator, use [`fuse`].","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`fuse`]: Iterator::fuse","highlight_start":1,"highlight_end":33},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iter_map_while\", since = \"1.57.0\")]","highlight_start":1,"highlight_end":60},{"text":"    fn map_while<B, P>(self, predicate: P) -> MapWhile<Self, P>","highlight_start":1,"highlight_end":64},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        P: FnMut(Self::Item) -> Option<B>,","highlight_start":1,"highlight_end":43},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        MapWhile::new(self, predicate)","highlight_start":1,"highlight_end":39},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator that skips the first `n` elements.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `skip(n)` skips elements until `n` elements are skipped or the end of the","highlight_start":1,"highlight_end":82},{"text":"    /// iterator is reached (whichever happens first). After that, all the remaining","highlight_start":1,"highlight_end":85},{"text":"    /// elements are yielded. In particular, if the original iterator is too short,","highlight_start":1,"highlight_end":84},{"text":"    /// then the returned iterator is empty.","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Rather than overriding this method directly, instead override the `nth` method.","highlight_start":1,"highlight_end":88},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().skip(2);","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn skip(self, n: usize) -> Skip<Self>","highlight_start":1,"highlight_end":42},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Skip::new(self, n)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator that yields the first `n` elements, or fewer","highlight_start":1,"highlight_end":73},{"text":"    /// if the underlying iterator ends sooner.","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `take(n)` yields elements until `n` elements are yielded or the end of","highlight_start":1,"highlight_end":79},{"text":"    /// the iterator is reached (whichever happens first).","highlight_start":1,"highlight_end":59},{"text":"    /// The returned iterator is a prefix of length `n` if the original iterator","highlight_start":1,"highlight_end":81},{"text":"    /// contains at least `n` elements, otherwise it contains all of the","highlight_start":1,"highlight_end":73},{"text":"    /// (fewer than `n`) elements of the original iterator.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().take(2);","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `take()` is often used with an infinite iterator, to make it finite:","highlight_start":1,"highlight_end":77},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let mut iter = (0..).take(3);","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(0));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), Some(1));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), Some(2));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If less than `n` elements are available,","highlight_start":1,"highlight_end":49},{"text":"    /// `take` will limit itself to the size of the underlying iterator:","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let v = [1, 2];","highlight_start":1,"highlight_end":24},{"text":"    /// let mut iter = v.into_iter().take(5);","highlight_start":1,"highlight_end":46},{"text":"    /// assert_eq!(iter.next(), Some(1));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), Some(2));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn take(self, n: usize) -> Take<Self>","highlight_start":1,"highlight_end":42},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Take::new(self, n)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// An iterator adapter similar to [`fold`] that holds internal state and","highlight_start":1,"highlight_end":78},{"text":"    /// produces a new iterator.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`fold`]: Iterator::fold","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `scan()` takes two arguments: an initial value which seeds the internal","highlight_start":1,"highlight_end":80},{"text":"    /// state, and a closure with two arguments, the first being a mutable","highlight_start":1,"highlight_end":75},{"text":"    /// reference to the internal state and the second an iterator element.","highlight_start":1,"highlight_end":76},{"text":"    /// The closure can assign to the internal state to share state between","highlight_start":1,"highlight_end":76},{"text":"    /// iterations.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// On iteration, the closure will be applied to each element of the","highlight_start":1,"highlight_end":73},{"text":"    /// iterator and the return value from the closure, an [`Option`], is","highlight_start":1,"highlight_end":74},{"text":"    /// yielded by the iterator.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().scan(1, |state, &x| {","highlight_start":1,"highlight_end":54},{"text":"    ///     // each iteration, we'll multiply the state by the element","highlight_start":1,"highlight_end":71},{"text":"    ///     *state = *state * x;","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     // then, we'll yield the negation of the state","highlight_start":1,"highlight_end":59},{"text":"    ///     Some(-*state)","highlight_start":1,"highlight_end":26},{"text":"    /// });","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(-1));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(-2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(-6));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>","highlight_start":1,"highlight_end":74},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(&mut St, Self::Item) -> Option<B>,","highlight_start":1,"highlight_end":52},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Scan::new(self, initial_state, f)","highlight_start":1,"highlight_end":42},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator that works like map, but flattens nested structure.","highlight_start":1,"highlight_end":80},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The [`map`] adapter is very useful, but only when the closure","highlight_start":1,"highlight_end":70},{"text":"    /// argument produces values. If it produces an iterator instead, there's","highlight_start":1,"highlight_end":78},{"text":"    /// an extra layer of indirection. `flat_map()` will remove this extra layer","highlight_start":1,"highlight_end":81},{"text":"    /// on its own.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// You can think of `flat_map(f)` as the semantic equivalent","highlight_start":1,"highlight_end":66},{"text":"    /// of [`map`]ping, and then [`flatten`]ing as in `map(f).flatten()`.","highlight_start":1,"highlight_end":74},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Another way of thinking about `flat_map()`: [`map`]'s closure returns","highlight_start":1,"highlight_end":78},{"text":"    /// one item for each element, and `flat_map()`'s closure returns an","highlight_start":1,"highlight_end":73},{"text":"    /// iterator for each element.","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`map`]: Iterator::map","highlight_start":1,"highlight_end":31},{"text":"    /// [`flatten`]: Iterator::flatten","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let words = [\"alpha\", \"beta\", \"gamma\"];","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // chars() returns an iterator","highlight_start":1,"highlight_end":39},{"text":"    /// let merged: String = words.iter()","highlight_start":1,"highlight_end":42},{"text":"    ///                           .flat_map(|s| s.chars())","highlight_start":1,"highlight_end":59},{"text":"    ///                           .collect();","highlight_start":1,"highlight_end":46},{"text":"    /// assert_eq!(merged, \"alphabetagamma\");","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>","highlight_start":1,"highlight_end":57},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        U: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        F: FnMut(Self::Item) -> U,","highlight_start":1,"highlight_end":35},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        FlatMap::new(self, f)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator that flattens nested structure.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This is useful when you have an iterator of iterators or an iterator of","highlight_start":1,"highlight_end":80},{"text":"    /// things that can be turned into iterators and you want to remove one","highlight_start":1,"highlight_end":76},{"text":"    /// level of indirection.","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let data = vec![vec![1, 2, 3, 4], vec![5, 6]];","highlight_start":1,"highlight_end":55},{"text":"    /// let flattened = data.into_iter().flatten().collect::<Vec<u8>>();","highlight_start":1,"highlight_end":73},{"text":"    /// assert_eq!(flattened, &[1, 2, 3, 4, 5, 6]);","highlight_start":1,"highlight_end":52},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Mapping and then flattening:","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let words = [\"alpha\", \"beta\", \"gamma\"];","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // chars() returns an iterator","highlight_start":1,"highlight_end":39},{"text":"    /// let merged: String = words.iter()","highlight_start":1,"highlight_end":42},{"text":"    ///                           .map(|s| s.chars())","highlight_start":1,"highlight_end":54},{"text":"    ///                           .flatten()","highlight_start":1,"highlight_end":45},{"text":"    ///                           .collect();","highlight_start":1,"highlight_end":46},{"text":"    /// assert_eq!(merged, \"alphabetagamma\");","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// You can also rewrite this in terms of [`flat_map()`], which is preferable","highlight_start":1,"highlight_end":82},{"text":"    /// in this case since it conveys intent more clearly:","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let words = [\"alpha\", \"beta\", \"gamma\"];","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // chars() returns an iterator","highlight_start":1,"highlight_end":39},{"text":"    /// let merged: String = words.iter()","highlight_start":1,"highlight_end":42},{"text":"    ///                           .flat_map(|s| s.chars())","highlight_start":1,"highlight_end":59},{"text":"    ///                           .collect();","highlight_start":1,"highlight_end":46},{"text":"    /// assert_eq!(merged, \"alphabetagamma\");","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Flattening only removes one level of nesting at a time:","highlight_start":1,"highlight_end":64},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let d2 = d3.iter().flatten().collect::<Vec<_>>();","highlight_start":1,"highlight_end":58},{"text":"    /// assert_eq!(d2, [&[1, 2], &[3, 4], &[5, 6], &[7, 8]]);","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let d1 = d3.iter().flatten().flatten().collect::<Vec<_>>();","highlight_start":1,"highlight_end":68},{"text":"    /// assert_eq!(d1, [&1, &2, &3, &4, &5, &6, &7, &8]);","highlight_start":1,"highlight_end":58},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Here we see that `flatten()` does not perform a \"deep\" flatten.","highlight_start":1,"highlight_end":72},{"text":"    /// Instead, only one level of nesting is removed. That is, if you","highlight_start":1,"highlight_end":71},{"text":"    /// `flatten()` a three-dimensional array, the result will be","highlight_start":1,"highlight_end":66},{"text":"    /// two-dimensional and not one-dimensional. To get a one-dimensional","highlight_start":1,"highlight_end":74},{"text":"    /// structure, you have to `flatten()` again.","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`flat_map()`]: Iterator::flat_map","highlight_start":1,"highlight_end":43},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]","highlight_start":1,"highlight_end":62},{"text":"    fn flatten(self) -> Flatten<Self>","highlight_start":1,"highlight_end":38},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        Self::Item: IntoIterator,","highlight_start":1,"highlight_end":34},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Flatten::new(self)","highlight_start":1,"highlight_end":27},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator which ends after the first [`None`].","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// After an iterator returns [`None`], future calls may or may not yield","highlight_start":1,"highlight_end":78},{"text":"    /// [`Some(T)`] again. `fuse()` adapts an iterator, ensuring that after a","highlight_start":1,"highlight_end":78},{"text":"    /// [`None`] is given, it will always return [`None`] forever.","highlight_start":1,"highlight_end":67},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that the [`Fuse`] wrapper is a no-op on iterators that implement","highlight_start":1,"highlight_end":78},{"text":"    /// the [`FusedIterator`] trait. `fuse()` may therefore behave incorrectly","highlight_start":1,"highlight_end":79},{"text":"    /// if the [`FusedIterator`] trait is improperly implemented.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Some(T)`]: Some","highlight_start":1,"highlight_end":26},{"text":"    /// [`FusedIterator`]: crate::iter::FusedIterator","highlight_start":1,"highlight_end":54},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// // an iterator which alternates between Some and None","highlight_start":1,"highlight_end":62},{"text":"    /// struct Alternate {","highlight_start":1,"highlight_end":27},{"text":"    ///     state: i32,","highlight_start":1,"highlight_end":24},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// impl Iterator for Alternate {","highlight_start":1,"highlight_end":38},{"text":"    ///     type Item = i32;","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     fn next(&mut self) -> Option<i32> {","highlight_start":1,"highlight_end":48},{"text":"    ///         let val = self.state;","highlight_start":1,"highlight_end":38},{"text":"    ///         self.state = self.state + 1;","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///         // if it's even, Some(i32), else None","highlight_start":1,"highlight_end":54},{"text":"    ///         if val % 2 == 0 {","highlight_start":1,"highlight_end":34},{"text":"    ///             Some(val)","highlight_start":1,"highlight_end":30},{"text":"    ///         } else {","highlight_start":1,"highlight_end":25},{"text":"    ///             None","highlight_start":1,"highlight_end":25},{"text":"    ///         }","highlight_start":1,"highlight_end":18},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = Alternate { state: 0 };","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // we can see our iterator going back and forth","highlight_start":1,"highlight_end":56},{"text":"    /// assert_eq!(iter.next(), Some(0));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// assert_eq!(iter.next(), Some(2));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // however, once we fuse it...","highlight_start":1,"highlight_end":39},{"text":"    /// let mut iter = iter.fuse();","highlight_start":1,"highlight_end":36},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(4));","highlight_start":1,"highlight_end":42},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // it will always return `None` after the first time.","highlight_start":1,"highlight_end":62},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn fuse(self) -> Fuse<Self>","highlight_start":1,"highlight_end":32},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Fuse::new(self)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Does something with each element of an iterator, passing the value on.","highlight_start":1,"highlight_end":79},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// When using iterators, you'll often chain several of them together.","highlight_start":1,"highlight_end":75},{"text":"    /// While working on such code, you might want to check out what's","highlight_start":1,"highlight_end":71},{"text":"    /// happening at various parts in the pipeline. To do that, insert","highlight_start":1,"highlight_end":71},{"text":"    /// a call to `inspect()`.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// It's more common for `inspect()` to be used as a debugging tool than to","highlight_start":1,"highlight_end":80},{"text":"    /// exist in your final code, but applications may find it useful in certain","highlight_start":1,"highlight_end":81},{"text":"    /// situations when errors need to be logged before being discarded.","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 4, 2, 3];","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // this iterator sequence is complex.","highlight_start":1,"highlight_end":46},{"text":"    /// let sum = a.iter()","highlight_start":1,"highlight_end":27},{"text":"    ///     .cloned()","highlight_start":1,"highlight_end":22},{"text":"    ///     .filter(|x| x % 2 == 0)","highlight_start":1,"highlight_end":36},{"text":"    ///     .fold(0, |sum, i| sum + i);","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// println!(\"{sum}\");","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // let's add some inspect() calls to investigate what's happening","highlight_start":1,"highlight_end":74},{"text":"    /// let sum = a.iter()","highlight_start":1,"highlight_end":27},{"text":"    ///     .cloned()","highlight_start":1,"highlight_end":22},{"text":"    ///     .inspect(|x| println!(\"about to filter: {x}\"))","highlight_start":1,"highlight_end":59},{"text":"    ///     .filter(|x| x % 2 == 0)","highlight_start":1,"highlight_end":36},{"text":"    ///     .inspect(|x| println!(\"made it through filter: {x}\"))","highlight_start":1,"highlight_end":66},{"text":"    ///     .fold(0, |sum, i| sum + i);","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// println!(\"{sum}\");","highlight_start":1,"highlight_end":27},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This will print:","highlight_start":1,"highlight_end":25},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// 6","highlight_start":1,"highlight_end":10},{"text":"    /// about to filter: 1","highlight_start":1,"highlight_end":27},{"text":"    /// about to filter: 4","highlight_start":1,"highlight_end":27},{"text":"    /// made it through filter: 4","highlight_start":1,"highlight_end":34},{"text":"    /// about to filter: 2","highlight_start":1,"highlight_end":27},{"text":"    /// made it through filter: 2","highlight_start":1,"highlight_end":34},{"text":"    /// about to filter: 3","highlight_start":1,"highlight_end":27},{"text":"    /// 6","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Logging errors before discarding them:","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let lines = [\"1\", \"2\", \"a\"];","highlight_start":1,"highlight_end":37},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let sum: i32 = lines","highlight_start":1,"highlight_end":29},{"text":"    ///     .iter()","highlight_start":1,"highlight_end":20},{"text":"    ///     .map(|line| line.parse::<i32>())","highlight_start":1,"highlight_end":45},{"text":"    ///     .inspect(|num| {","highlight_start":1,"highlight_end":29},{"text":"    ///         if let Err(ref e) = *num {","highlight_start":1,"highlight_end":43},{"text":"    ///             println!(\"Parsing error: {e}\");","highlight_start":1,"highlight_end":52},{"text":"    ///         }","highlight_start":1,"highlight_end":18},{"text":"    ///     })","highlight_start":1,"highlight_end":15},{"text":"    ///     .filter_map(Result::ok)","highlight_start":1,"highlight_end":36},{"text":"    ///     .sum();","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// println!(\"Sum: {sum}\");","highlight_start":1,"highlight_end":32},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This will print:","highlight_start":1,"highlight_end":25},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// Parsing error: invalid digit found in string","highlight_start":1,"highlight_end":53},{"text":"    /// Sum: 3","highlight_start":1,"highlight_end":15},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn inspect<F>(self, f: F) -> Inspect<Self, F>","highlight_start":1,"highlight_end":50},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(&Self::Item),","highlight_start":1,"highlight_end":31},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Inspect::new(self, f)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Borrows an iterator, rather than consuming it.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This is useful to allow applying iterator adapters while still","highlight_start":1,"highlight_end":71},{"text":"    /// retaining ownership of the original iterator.","highlight_start":1,"highlight_end":54},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let mut words = [\"hello\", \"world\", \"of\", \"Rust\"].into_iter();","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Take the first two words.","highlight_start":1,"highlight_end":37},{"text":"    /// let hello_world: Vec<_> = words.by_ref().take(2).collect();","highlight_start":1,"highlight_end":68},{"text":"    /// assert_eq!(hello_world, vec![\"hello\", \"world\"]);","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Collect the rest of the words.","highlight_start":1,"highlight_end":42},{"text":"    /// // We can only do this because we used `by_ref` earlier.","highlight_start":1,"highlight_end":65},{"text":"    /// let of_rust: Vec<_> = words.collect();","highlight_start":1,"highlight_end":47},{"text":"    /// assert_eq!(of_rust, vec![\"of\", \"Rust\"]);","highlight_start":1,"highlight_end":49},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn by_ref(&mut self) -> &mut Self","highlight_start":1,"highlight_end":38},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self","highlight_start":1,"highlight_end":13},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Transforms an iterator into a collection.","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `collect()` can take anything iterable, and turn it into a relevant","highlight_start":1,"highlight_end":76},{"text":"    /// collection. This is one of the more powerful methods in the standard","highlight_start":1,"highlight_end":77},{"text":"    /// library, used in a variety of contexts.","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The most basic pattern in which `collect()` is used is to turn one","highlight_start":1,"highlight_end":75},{"text":"    /// collection into another. You take a collection, call [`iter`] on it,","highlight_start":1,"highlight_end":77},{"text":"    /// do a bunch of transformations, and then `collect()` at the end.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `collect()` can also create instances of types that are not typical","highlight_start":1,"highlight_end":76},{"text":"    /// collections. For example, a [`String`] can be built from [`char`]s,","highlight_start":1,"highlight_end":76},{"text":"    /// and an iterator of [`Result<T, E>`][`Result`] items can be collected","highlight_start":1,"highlight_end":77},{"text":"    /// into `Result<Collection<T>, E>`. See the examples below for more.","highlight_start":1,"highlight_end":74},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Because `collect()` is so general, it can cause problems with type","highlight_start":1,"highlight_end":75},{"text":"    /// inference. As such, `collect()` is one of the few times you'll see","highlight_start":1,"highlight_end":75},{"text":"    /// the syntax affectionately known as the 'turbofish': `::<>`. This","highlight_start":1,"highlight_end":73},{"text":"    /// helps the inference algorithm understand specifically which collection","highlight_start":1,"highlight_end":79},{"text":"    /// you're trying to collect into.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let doubled: Vec<i32> = a.iter()","highlight_start":1,"highlight_end":41},{"text":"    ///                          .map(|&x| x * 2)","highlight_start":1,"highlight_end":50},{"text":"    ///                          .collect();","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(vec![2, 4, 6], doubled);","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that we needed the `: Vec<i32>` on the left-hand side. This is because","highlight_start":1,"highlight_end":84},{"text":"    /// we could collect into, for example, a [`VecDeque<T>`] instead:","highlight_start":1,"highlight_end":71},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use std::collections::VecDeque;","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let doubled: VecDeque<i32> = a.iter().map(|&x| x * 2).collect();","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(2, doubled[0]);","highlight_start":1,"highlight_end":35},{"text":"    /// assert_eq!(4, doubled[1]);","highlight_start":1,"highlight_end":35},{"text":"    /// assert_eq!(6, doubled[2]);","highlight_start":1,"highlight_end":35},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Using the 'turbofish' instead of annotating `doubled`:","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(vec![2, 4, 6], doubled);","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Because `collect()` only cares about what you're collecting into, you can","highlight_start":1,"highlight_end":82},{"text":"    /// still use a partial type hint, `_`, with the turbofish:","highlight_start":1,"highlight_end":64},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();","highlight_start":1,"highlight_end":67},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(vec![2, 4, 6], doubled);","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Using `collect()` to make a [`String`]:","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let chars = ['g', 'd', 'k', 'k', 'n'];","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let hello: String = chars.iter()","highlight_start":1,"highlight_end":41},{"text":"    ///     .map(|&x| x as u8)","highlight_start":1,"highlight_end":31},{"text":"    ///     .map(|x| (x + 1) as char)","highlight_start":1,"highlight_end":38},{"text":"    ///     .collect();","highlight_start":1,"highlight_end":24},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(\"hello\", hello);","highlight_start":1,"highlight_end":36},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to","highlight_start":1,"highlight_end":86},{"text":"    /// see if any of them failed:","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();","highlight_start":1,"highlight_end":78},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // gives us the first error","highlight_start":1,"highlight_end":36},{"text":"    /// assert_eq!(Err(\"nope\"), result);","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let results = [Ok(1), Ok(3)];","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result: Result<Vec<_>, &str> = results.iter().cloned().collect();","highlight_start":1,"highlight_end":78},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // gives us the list of answers","highlight_start":1,"highlight_end":40},{"text":"    /// assert_eq!(Ok(vec![1, 3]), result);","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`iter`]: Iterator::next","highlight_start":1,"highlight_end":33},{"text":"    /// [`String`]: ../../std/string/struct.String.html","highlight_start":1,"highlight_end":56},{"text":"    /// [`char`]: type@char","highlight_start":1,"highlight_end":28},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    #[must_use = \"if you really need to exhaust the iterator, consider `.for_each(drop)` instead\"]","highlight_start":1,"highlight_end":99},{"text":"    fn collect<B: FromIterator<Self::Item>>(self) -> B","highlight_start":1,"highlight_end":55},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        FromIterator::from_iter(self)","highlight_start":1,"highlight_end":38},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Fallibly transforms an iterator into a collection, short circuiting if","highlight_start":1,"highlight_end":79},{"text":"    /// a failure is encountered.","highlight_start":1,"highlight_end":34},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `try_collect()` is a variation of [`collect()`][`collect`] that allows fallible","highlight_start":1,"highlight_end":88},{"text":"    /// conversions during collection. Its main use case is simplifying conversions from","highlight_start":1,"highlight_end":89},{"text":"    /// iterators yielding [`Option<T>`][`Option`] into `Option<Collection<T>>`, or similarly for other [`Try`]","highlight_start":1,"highlight_end":112},{"text":"    /// types (e.g. [`Result`]).","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Importantly, `try_collect()` doesn't require that the outer [`Try`] type also implements [`FromIterator`];","highlight_start":1,"highlight_end":115},{"text":"    /// only the inner type produced on `Try::Output` must implement it. Concretely,","highlight_start":1,"highlight_end":85},{"text":"    /// this means that collecting into `ControlFlow<_, Vec<i32>>` is valid because `Vec<i32>` implements","highlight_start":1,"highlight_end":106},{"text":"    /// [`FromIterator`], even though [`ControlFlow`] doesn't.","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Also, if a failure is encountered during `try_collect()`, the iterator is still valid and","highlight_start":1,"highlight_end":98},{"text":"    /// may continue to be used, in which case it will continue iterating starting after the element that","highlight_start":1,"highlight_end":106},{"text":"    /// triggered the failure. See the last example below for an example of how this works.","highlight_start":1,"highlight_end":92},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    /// Successfully collecting an iterator of `Option<i32>` into `Option<Vec<i32>>`:","highlight_start":1,"highlight_end":86},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iterator_try_collect)]","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let u = vec![Some(1), Some(2), Some(3)];","highlight_start":1,"highlight_end":49},{"text":"    /// let v = u.into_iter().try_collect::<Vec<i32>>();","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!(v, Some(vec![1, 2, 3]));","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Failing to collect in the same way:","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iterator_try_collect)]","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let u = vec![Some(1), Some(2), None, Some(3)];","highlight_start":1,"highlight_end":55},{"text":"    /// let v = u.into_iter().try_collect::<Vec<i32>>();","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!(v, None);","highlight_start":1,"highlight_end":29},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// A similar example, but with `Result`:","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iterator_try_collect)]","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let u: Vec<Result<i32, ()>> = vec![Ok(1), Ok(2), Ok(3)];","highlight_start":1,"highlight_end":65},{"text":"    /// let v = u.into_iter().try_collect::<Vec<i32>>();","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!(v, Ok(vec![1, 2, 3]));","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let u = vec![Ok(1), Ok(2), Err(()), Ok(3)];","highlight_start":1,"highlight_end":52},{"text":"    /// let v = u.into_iter().try_collect::<Vec<i32>>();","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!(v, Err(()));","highlight_start":1,"highlight_end":32},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Finally, even [`ControlFlow`] works, despite the fact that it","highlight_start":1,"highlight_end":70},{"text":"    /// doesn't implement [`FromIterator`]. Note also that the iterator can","highlight_start":1,"highlight_end":76},{"text":"    /// continue to be used, even if a failure is encountered:","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iterator_try_collect)]","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// use core::ops::ControlFlow::{Break, Continue};","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];","highlight_start":1,"highlight_end":80},{"text":"    /// let mut it = u.into_iter();","highlight_start":1,"highlight_end":36},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let v = it.try_collect::<Vec<_>>();","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(v, Break(3));","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let v = it.try_collect::<Vec<_>>();","highlight_start":1,"highlight_end":44},{"text":"    /// assert_eq!(v, Continue(vec![4, 5]));","highlight_start":1,"highlight_end":45},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`collect`]: Iterator::collect","highlight_start":1,"highlight_end":39},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"iterator_try_collect\", issue = \"94047\")]","highlight_start":1,"highlight_end":67},{"text":"    fn try_collect<B>(&mut self) -> ChangeOutputType<Self::Item, B>","highlight_start":1,"highlight_end":68},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        <Self as Iterator>::Item: Try,","highlight_start":1,"highlight_end":39},{"text":"        <<Self as Iterator>::Item as Try>::Residual: Residual<B>,","highlight_start":1,"highlight_end":66},{"text":"        B: FromIterator<<Self::Item as Try>::Output>,","highlight_start":1,"highlight_end":54},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        try_process(ByRefSized(self), |i| i.collect())","highlight_start":1,"highlight_end":55},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Collects all the items from an iterator into a collection.","highlight_start":1,"highlight_end":67},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method consumes the iterator and adds all its items to the","highlight_start":1,"highlight_end":72},{"text":"    /// passed collection. The collection is then returned, so the call chain","highlight_start":1,"highlight_end":78},{"text":"    /// can be continued.","highlight_start":1,"highlight_end":26},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This is useful when you already have a collection and wants to add","highlight_start":1,"highlight_end":75},{"text":"    /// the iterator items to it.","highlight_start":1,"highlight_end":34},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This method is a convenience method to call [Extend::extend](trait.Extend.html),","highlight_start":1,"highlight_end":89},{"text":"    /// but instead of being called on a collection, it's called on an iterator.","highlight_start":1,"highlight_end":81},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_collect_into)]","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// let mut vec: Vec::<i32> = vec![0, 1];","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// a.iter().map(|&x| x * 2).collect_into(&mut vec);","highlight_start":1,"highlight_end":57},{"text":"    /// a.iter().map(|&x| x * 10).collect_into(&mut vec);","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(vec![0, 1, 2, 4, 6, 10, 20, 30], vec);","highlight_start":1,"highlight_end":58},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `Vec` can have a manual set capacity to avoid reallocating it:","highlight_start":1,"highlight_end":71},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_collect_into)]","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// let mut vec: Vec::<i32> = Vec::with_capacity(6);","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// a.iter().map(|&x| x * 2).collect_into(&mut vec);","highlight_start":1,"highlight_end":57},{"text":"    /// a.iter().map(|&x| x * 10).collect_into(&mut vec);","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(6, vec.capacity());","highlight_start":1,"highlight_end":39},{"text":"    /// println!(\"{:?}\", vec);","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The returned mutable reference can be used to continue the call chain:","highlight_start":1,"highlight_end":79},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_collect_into)]","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// let mut vec: Vec::<i32> = Vec::with_capacity(6);","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let count = a.iter().collect_into(&mut vec).iter().count();","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(count, vec.len());","highlight_start":1,"highlight_end":38},{"text":"    /// println!(\"Vec len is {}\", count);","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let count = a.iter().collect_into(&mut vec).iter().count();","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(count, vec.len());","highlight_start":1,"highlight_end":38},{"text":"    /// println!(\"Vec len now is {}\", count);","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"iter_collect_into\", reason = \"new API\", issue = \"94780\")]","highlight_start":1,"highlight_end":84},{"text":"    fn collect_into<E: Extend<Self::Item>>(self, collection: &mut E) -> &mut E","highlight_start":1,"highlight_end":79},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        collection.extend(self);","highlight_start":1,"highlight_end":33},{"text":"        collection","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Consumes an iterator, creating two collections from it.","highlight_start":1,"highlight_end":64},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The predicate passed to `partition()` can return `true`, or `false`.","highlight_start":1,"highlight_end":77},{"text":"    /// `partition()` returns a pair, all of the elements for which it returned","highlight_start":1,"highlight_end":80},{"text":"    /// `true`, and all of the elements for which it returned `false`.","highlight_start":1,"highlight_end":71},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// See also [`is_partitioned()`] and [`partition_in_place()`].","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`is_partitioned()`]: Iterator::is_partitioned","highlight_start":1,"highlight_end":55},{"text":"    /// [`partition_in_place()`]: Iterator::partition_in_place","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let (even, odd): (Vec<_>, Vec<_>) = a","highlight_start":1,"highlight_end":46},{"text":"    ///     .into_iter()","highlight_start":1,"highlight_end":25},{"text":"    ///     .partition(|n| n % 2 == 0);","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(even, vec![2]);","highlight_start":1,"highlight_end":35},{"text":"    /// assert_eq!(odd, vec![1, 3]);","highlight_start":1,"highlight_end":37},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn partition<B, F>(self, f: F) -> (B, B)","highlight_start":1,"highlight_end":45},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        B: Default + Extend<Self::Item>,","highlight_start":1,"highlight_end":41},{"text":"        F: FnMut(&Self::Item) -> bool,","highlight_start":1,"highlight_end":39},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn extend<'a, T, B: Extend<T>>(","highlight_start":1,"highlight_end":40},{"text":"            mut f: impl FnMut(&T) -> bool + 'a,","highlight_start":1,"highlight_end":48},{"text":"            left: &'a mut B,","highlight_start":1,"highlight_end":29},{"text":"            right: &'a mut B,","highlight_start":1,"highlight_end":30},{"text":"        ) -> impl FnMut((), T) + 'a {","highlight_start":1,"highlight_end":38},{"text":"            move |(), x| {","highlight_start":1,"highlight_end":27},{"text":"                if f(&x) {","highlight_start":1,"highlight_end":27},{"text":"                    left.extend_one(x);","highlight_start":1,"highlight_end":40},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    right.extend_one(x);","highlight_start":1,"highlight_end":41},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut left: B = Default::default();","highlight_start":1,"highlight_end":46},{"text":"        let mut right: B = Default::default();","highlight_start":1,"highlight_end":47},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.fold((), extend(f, &mut left, &mut right));","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        (left, right)","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Reorders the elements of this iterator *in-place* according to the given predicate,","highlight_start":1,"highlight_end":92},{"text":"    /// such that all those that return `true` precede all those that return `false`.","highlight_start":1,"highlight_end":86},{"text":"    /// Returns the number of `true` elements found.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The relative order of partitioned items is not maintained.","highlight_start":1,"highlight_end":67},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Current implementation","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Current algorithms tries finding the first element for which the predicate evaluates","highlight_start":1,"highlight_end":93},{"text":"    /// to false, and the last element for which it evaluates to true and repeatedly swaps them.","highlight_start":1,"highlight_end":97},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Time complexity: *O*(*n*)","highlight_start":1,"highlight_end":34},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// See also [`is_partitioned()`] and [`partition()`].","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`is_partitioned()`]: Iterator::is_partitioned","highlight_start":1,"highlight_end":55},{"text":"    /// [`partition()`]: Iterator::partition","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_partition_in_place)]","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut a = [1, 2, 3, 4, 5, 6, 7];","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Partition in-place between evens and odds","highlight_start":1,"highlight_end":53},{"text":"    /// let i = a.iter_mut().partition_in_place(|&n| n % 2 == 0);","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(i, 3);","highlight_start":1,"highlight_end":26},{"text":"    /// assert!(a[..i].iter().all(|&n| n % 2 == 0)); // evens","highlight_start":1,"highlight_end":62},{"text":"    /// assert!(a[i..].iter().all(|&n| n % 2 == 1)); // odds","highlight_start":1,"highlight_end":61},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[unstable(feature = \"iter_partition_in_place\", reason = \"new API\", issue = \"62543\")]","highlight_start":1,"highlight_end":90},{"text":"    fn partition_in_place<'a, T: 'a, P>(mut self, ref mut predicate: P) -> usize","highlight_start":1,"highlight_end":81},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized + DoubleEndedIterator<Item = &'a mut T>,","highlight_start":1,"highlight_end":61},{"text":"        P: FnMut(&T) -> bool,","highlight_start":1,"highlight_end":30},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        // FIXME: should we worry about the count overflowing? The only way to have more than","highlight_start":1,"highlight_end":94},{"text":"        // `usize::MAX` mutable references is with ZSTs, which aren't useful to partition...","highlight_start":1,"highlight_end":93},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // These closure \"factory\" functions exist to avoid genericity in `Self`.","highlight_start":1,"highlight_end":82},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn is_false<'a, T>(","highlight_start":1,"highlight_end":28},{"text":"            predicate: &'a mut impl FnMut(&T) -> bool,","highlight_start":1,"highlight_end":55},{"text":"            true_count: &'a mut usize,","highlight_start":1,"highlight_end":39},{"text":"        ) -> impl FnMut(&&mut T) -> bool + 'a {","highlight_start":1,"highlight_end":48},{"text":"            move |x| {","highlight_start":1,"highlight_end":23},{"text":"                let p = predicate(&**x);","highlight_start":1,"highlight_end":41},{"text":"                *true_count += p as usize;","highlight_start":1,"highlight_end":43},{"text":"                !p","highlight_start":1,"highlight_end":19},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn is_true<T>(predicate: &mut impl FnMut(&T) -> bool) -> impl FnMut(&&mut T) -> bool + '_ {","highlight_start":1,"highlight_end":100},{"text":"            move |x| predicate(&**x)","highlight_start":1,"highlight_end":37},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Repeatedly find the first `false` and swap it with the last `true`.","highlight_start":1,"highlight_end":79},{"text":"        let mut true_count = 0;","highlight_start":1,"highlight_end":32},{"text":"        while let Some(head) = self.find(is_false(predicate, &mut true_count)) {","highlight_start":1,"highlight_end":81},{"text":"            if let Some(tail) = self.rfind(is_true(predicate)) {","highlight_start":1,"highlight_end":65},{"text":"                crate::mem::swap(head, tail);","highlight_start":1,"highlight_end":46},{"text":"                true_count += 1;","highlight_start":1,"highlight_end":33},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"                break;","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        true_count","highlight_start":1,"highlight_end":19},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if the elements of this iterator are partitioned according to the given predicate,","highlight_start":1,"highlight_end":98},{"text":"    /// such that all those that return `true` precede all those that return `false`.","highlight_start":1,"highlight_end":86},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// See also [`partition()`] and [`partition_in_place()`].","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`partition()`]: Iterator::partition","highlight_start":1,"highlight_end":45},{"text":"    /// [`partition_in_place()`]: Iterator::partition_in_place","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_is_partitioned)]","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!(\"Iterator\".chars().is_partitioned(char::is_uppercase));","highlight_start":1,"highlight_end":72},{"text":"    /// assert!(!\"IntoIterator\".chars().is_partitioned(char::is_uppercase));","highlight_start":1,"highlight_end":77},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[unstable(feature = \"iter_is_partitioned\", reason = \"new API\", issue = \"62544\")]","highlight_start":1,"highlight_end":86},{"text":"    fn is_partitioned<P>(mut self, mut predicate: P) -> bool","highlight_start":1,"highlight_end":61},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        P: FnMut(Self::Item) -> bool,","highlight_start":1,"highlight_end":38},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        // Either all items test `true`, or the first clause stops at `false`","highlight_start":1,"highlight_end":78},{"text":"        // and we check that there are no more `true` items after that.","highlight_start":1,"highlight_end":72},{"text":"        self.all(&mut predicate) || !self.any(predicate)","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// An iterator method that applies a function as long as it returns","highlight_start":1,"highlight_end":73},{"text":"    /// successfully, producing a single, final value.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `try_fold()` takes two arguments: an initial value, and a closure with","highlight_start":1,"highlight_end":79},{"text":"    /// two arguments: an 'accumulator', and an element. The closure either","highlight_start":1,"highlight_end":76},{"text":"    /// returns successfully, with the value that the accumulator should have","highlight_start":1,"highlight_end":78},{"text":"    /// for the next iteration, or it returns failure, with an error value that","highlight_start":1,"highlight_end":80},{"text":"    /// is propagated back to the caller immediately (short-circuiting).","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The initial value is the value the accumulator will have on the first","highlight_start":1,"highlight_end":78},{"text":"    /// call. If applying the closure succeeded against every element of the","highlight_start":1,"highlight_end":77},{"text":"    /// iterator, `try_fold()` returns the final accumulator as success.","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Folding is useful whenever you have a collection of something, and want","highlight_start":1,"highlight_end":80},{"text":"    /// to produce a single value from it.","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Note to Implementors","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Several of the other (forward) methods have default implementations in","highlight_start":1,"highlight_end":79},{"text":"    /// terms of this one, so try to implement this explicitly if it can","highlight_start":1,"highlight_end":73},{"text":"    /// do something better than the default `for` loop implementation.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In particular, try to have this call `try_fold()` on the internal parts","highlight_start":1,"highlight_end":80},{"text":"    /// from which this iterator is composed. If multiple calls are needed,","highlight_start":1,"highlight_end":76},{"text":"    /// the `?` operator may be convenient for chaining the accumulator value","highlight_start":1,"highlight_end":78},{"text":"    /// along, but beware any invariants that need to be upheld before those","highlight_start":1,"highlight_end":77},{"text":"    /// early returns. This is a `&mut self` method, so iteration needs to be","highlight_start":1,"highlight_end":78},{"text":"    /// resumable after hitting an error here.","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // the checked sum of all of the elements of the array","highlight_start":1,"highlight_end":63},{"text":"    /// let sum = a.iter().try_fold(0i8, |acc, &x| acc.checked_add(x));","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(sum, Some(6));","highlight_start":1,"highlight_end":34},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Short-circuiting:","highlight_start":1,"highlight_end":26},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [10, 20, 30, 100, 40, 50];","highlight_start":1,"highlight_end":43},{"text":"    /// let mut it = a.iter();","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // This sum overflows when adding the 100 element","highlight_start":1,"highlight_end":58},{"text":"    /// let sum = it.try_fold(0i8, |acc, &x| acc.checked_add(x));","highlight_start":1,"highlight_end":66},{"text":"    /// assert_eq!(sum, None);","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Because it short-circuited, the remaining elements are still","highlight_start":1,"highlight_end":72},{"text":"    /// // available through the iterator.","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(it.len(), 2);","highlight_start":1,"highlight_end":33},{"text":"    /// assert_eq!(it.next(), Some(&40));","highlight_start":1,"highlight_end":42},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// While you cannot `break` from a closure, the [`ControlFlow`] type allows","highlight_start":1,"highlight_end":81},{"text":"    /// a similar idea:","highlight_start":1,"highlight_end":24},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use std::ops::ControlFlow;","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let triangular = (1..30).try_fold(0_i8, |prev, x| {","highlight_start":1,"highlight_end":60},{"text":"    ///     if let Some(next) = prev.checked_add(x) {","highlight_start":1,"highlight_end":54},{"text":"    ///         ControlFlow::Continue(next)","highlight_start":1,"highlight_end":44},{"text":"    ///     } else {","highlight_start":1,"highlight_end":21},{"text":"    ///         ControlFlow::Break(prev)","highlight_start":1,"highlight_end":41},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// });","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!(triangular, ControlFlow::Break(120));","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let triangular = (1..30).try_fold(0_u64, |prev, x| {","highlight_start":1,"highlight_end":61},{"text":"    ///     if let Some(next) = prev.checked_add(x) {","highlight_start":1,"highlight_end":54},{"text":"    ///         ControlFlow::Continue(next)","highlight_start":1,"highlight_end":44},{"text":"    ///     } else {","highlight_start":1,"highlight_end":21},{"text":"    ///         ControlFlow::Break(prev)","highlight_start":1,"highlight_end":41},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// });","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!(triangular, ControlFlow::Continue(435));","highlight_start":1,"highlight_end":60},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]","highlight_start":1,"highlight_end":63},{"text":"    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R","highlight_start":1,"highlight_end":60},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(B, Self::Item) -> R,","highlight_start":1,"highlight_end":38},{"text":"        R: Try<Output = B>,","highlight_start":1,"highlight_end":28},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        let mut accum = init;","highlight_start":1,"highlight_end":30},{"text":"        while let Some(x) = self.next() {","highlight_start":1,"highlight_end":42},{"text":"            accum = f(accum, x)?;","highlight_start":1,"highlight_end":34},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        try { accum }","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// An iterator method that applies a fallible function to each item in the","highlight_start":1,"highlight_end":80},{"text":"    /// iterator, stopping at the first error and returning that error.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This can also be thought of as the fallible form of [`for_each()`]","highlight_start":1,"highlight_end":75},{"text":"    /// or as the stateless version of [`try_fold()`].","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`for_each()`]: Iterator::for_each","highlight_start":1,"highlight_end":43},{"text":"    /// [`try_fold()`]: Iterator::try_fold","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use std::fs::rename;","highlight_start":1,"highlight_end":29},{"text":"    /// use std::io::{stdout, Write};","highlight_start":1,"highlight_end":38},{"text":"    /// use std::path::Path;","highlight_start":1,"highlight_end":29},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];","highlight_start":1,"highlight_end":78},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let res = data.iter().try_for_each(|x| writeln!(stdout(), \"{x}\"));","highlight_start":1,"highlight_end":75},{"text":"    /// assert!(res.is_ok());","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut it = data.iter().cloned();","highlight_start":1,"highlight_end":43},{"text":"    /// let res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));","highlight_start":1,"highlight_end":86},{"text":"    /// assert!(res.is_err());","highlight_start":1,"highlight_end":31},{"text":"    /// // It short-circuited, so the remaining items are still in the iterator:","highlight_start":1,"highlight_end":81},{"text":"    /// assert_eq!(it.next(), Some(\"stale_bread.json\"));","highlight_start":1,"highlight_end":57},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The [`ControlFlow`] type can be used with this method for the situations","highlight_start":1,"highlight_end":81},{"text":"    /// in which you'd use `break` and `continue` in a normal loop:","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use std::ops::ControlFlow;","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let r = (2..100).try_for_each(|x| {","highlight_start":1,"highlight_end":44},{"text":"    ///     if 323 % x == 0 {","highlight_start":1,"highlight_end":30},{"text":"    ///         return ControlFlow::Break(x)","highlight_start":1,"highlight_end":45},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    ///     ControlFlow::Continue(())","highlight_start":1,"highlight_end":38},{"text":"    /// });","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!(r, ControlFlow::Break(17));","highlight_start":1,"highlight_end":47},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]","highlight_start":1,"highlight_end":63},{"text":"    fn try_for_each<F, R>(&mut self, f: F) -> R","highlight_start":1,"highlight_end":48},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item) -> R,","highlight_start":1,"highlight_end":35},{"text":"        R: Try<Output = ()>,","highlight_start":1,"highlight_end":29},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn call<T, R>(mut f: impl FnMut(T) -> R) -> impl FnMut((), T) -> R {","highlight_start":1,"highlight_end":77},{"text":"            move |(), x| f(x)","highlight_start":1,"highlight_end":30},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.try_fold((), call(f))","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Folds every element into an accumulator by applying an operation,","highlight_start":1,"highlight_end":74},{"text":"    /// returning the final result.","highlight_start":1,"highlight_end":36},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `fold()` takes two arguments: an initial value, and a closure with two","highlight_start":1,"highlight_end":79},{"text":"    /// arguments: an 'accumulator', and an element. The closure returns the value that","highlight_start":1,"highlight_end":88},{"text":"    /// the accumulator should have for the next iteration.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The initial value is the value the accumulator will have on the first","highlight_start":1,"highlight_end":78},{"text":"    /// call.","highlight_start":1,"highlight_end":14},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// After applying this closure to every element of the iterator, `fold()`","highlight_start":1,"highlight_end":79},{"text":"    /// returns the accumulator.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This operation is sometimes called 'reduce' or 'inject'.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Folding is useful whenever you have a collection of something, and want","highlight_start":1,"highlight_end":80},{"text":"    /// to produce a single value from it.","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note: `fold()`, and similar methods that traverse the entire iterator,","highlight_start":1,"highlight_end":79},{"text":"    /// might not terminate for infinite iterators, even on traits for which a","highlight_start":1,"highlight_end":79},{"text":"    /// result is determinable in finite time.","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note: [`reduce()`] can be used to use the first element as the initial","highlight_start":1,"highlight_end":79},{"text":"    /// value, if the accumulator type and item type is the same.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note: `fold()` combines elements in a *left-associative* fashion. For associative","highlight_start":1,"highlight_end":90},{"text":"    /// operators like `+`, the order the elements are combined in is not important, but for non-associative","highlight_start":1,"highlight_end":109},{"text":"    /// operators like `-` the order will affect the final result.","highlight_start":1,"highlight_end":67},{"text":"    /// For a *right-associative* version of `fold()`, see [`DoubleEndedIterator::rfold()`].","highlight_start":1,"highlight_end":93},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Note to Implementors","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Several of the other (forward) methods have default implementations in","highlight_start":1,"highlight_end":79},{"text":"    /// terms of this one, so try to implement this explicitly if it can","highlight_start":1,"highlight_end":73},{"text":"    /// do something better than the default `for` loop implementation.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// In particular, try to have this call `fold()` on the internal parts","highlight_start":1,"highlight_end":76},{"text":"    /// from which this iterator is composed.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // the sum of all of the elements of the array","highlight_start":1,"highlight_end":55},{"text":"    /// let sum = a.iter().fold(0, |acc, x| acc + x);","highlight_start":1,"highlight_end":54},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(sum, 6);","highlight_start":1,"highlight_end":28},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Let's walk through each step of the iteration here:","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// | element | acc | x | result |","highlight_start":1,"highlight_end":39},{"text":"    /// |---------|-----|---|--------|","highlight_start":1,"highlight_end":39},{"text":"    /// |         | 0   |   |        |","highlight_start":1,"highlight_end":39},{"text":"    /// | 1       | 0   | 1 | 1      |","highlight_start":1,"highlight_end":39},{"text":"    /// | 2       | 1   | 2 | 3      |","highlight_start":1,"highlight_end":39},{"text":"    /// | 3       | 3   | 3 | 6      |","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// And so, our final result, `6`.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This example demonstrates the left-associative nature of `fold()`:","highlight_start":1,"highlight_end":75},{"text":"    /// it builds a string, starting with an initial value","highlight_start":1,"highlight_end":59},{"text":"    /// and continuing with each element from the front until the back:","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let numbers = [1, 2, 3, 4, 5];","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let zero = \"0\".to_string();","highlight_start":1,"highlight_end":36},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result = numbers.iter().fold(zero, |acc, &x| {","highlight_start":1,"highlight_end":59},{"text":"    ///     format!(\"({acc} + {x})\")","highlight_start":1,"highlight_end":37},{"text":"    /// });","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");","highlight_start":1,"highlight_end":63},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// It's common for people who haven't used iterators a lot to","highlight_start":1,"highlight_end":67},{"text":"    /// use a `for` loop with a list of things to build up a result. Those","highlight_start":1,"highlight_end":75},{"text":"    /// can be turned into `fold()`s:","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for","highlight_start":1,"highlight_end":92},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let numbers = [1, 2, 3, 4, 5];","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut result = 0;","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // for loop:","highlight_start":1,"highlight_end":21},{"text":"    /// for i in &numbers {","highlight_start":1,"highlight_end":28},{"text":"    ///     result = result + i;","highlight_start":1,"highlight_end":33},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // fold:","highlight_start":1,"highlight_end":17},{"text":"    /// let result2 = numbers.iter().fold(0, |acc, &x| acc + x);","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // they're the same","highlight_start":1,"highlight_end":28},{"text":"    /// assert_eq!(result, result2);","highlight_start":1,"highlight_end":37},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`reduce()`]: Iterator::reduce","highlight_start":1,"highlight_end":39},{"text":"    #[doc(alias = \"inject\", alias = \"foldl\")]","highlight_start":1,"highlight_end":46},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn fold<B, F>(mut self, init: B, mut f: F) -> B","highlight_start":1,"highlight_end":52},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(B, Self::Item) -> B,","highlight_start":1,"highlight_end":38},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        let mut accum = init;","highlight_start":1,"highlight_end":30},{"text":"        while let Some(x) = self.next() {","highlight_start":1,"highlight_end":42},{"text":"            accum = f(accum, x);","highlight_start":1,"highlight_end":33},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        accum","highlight_start":1,"highlight_end":14},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Reduces the elements to a single one, by repeatedly applying a reducing","highlight_start":1,"highlight_end":80},{"text":"    /// operation.","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If the iterator is empty, returns [`None`]; otherwise, returns the","highlight_start":1,"highlight_end":75},{"text":"    /// result of the reduction.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The reducing function is a closure with two arguments: an 'accumulator', and an element.","highlight_start":1,"highlight_end":97},{"text":"    /// For iterators with at least one element, this is the same as [`fold()`]","highlight_start":1,"highlight_end":80},{"text":"    /// with the first element of the iterator as the initial accumulator value, folding","highlight_start":1,"highlight_end":89},{"text":"    /// every subsequent element into it.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`fold()`]: Iterator::fold","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Example","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Find the maximum value:","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// fn find_max<I>(iter: I) -> Option<I::Item>","highlight_start":1,"highlight_end":51},{"text":"    ///     where I: Iterator,","highlight_start":1,"highlight_end":31},{"text":"    ///           I::Item: Ord,","highlight_start":1,"highlight_end":32},{"text":"    /// {","highlight_start":1,"highlight_end":10},{"text":"    ///     iter.reduce(|accum, item| {","highlight_start":1,"highlight_end":40},{"text":"    ///         if accum >= item { accum } else { item }","highlight_start":1,"highlight_end":57},{"text":"    ///     })","highlight_start":1,"highlight_end":15},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// let a = [10, 20, 5, -23, 0];","highlight_start":1,"highlight_end":37},{"text":"    /// let b: [u32; 0] = [];","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(find_max(a.iter()), Some(&20));","highlight_start":1,"highlight_end":51},{"text":"    /// assert_eq!(find_max(b.iter()), None);","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iterator_fold_self\", since = \"1.51.0\")]","highlight_start":1,"highlight_end":64},{"text":"    fn reduce<F>(mut self, f: F) -> Option<Self::Item>","highlight_start":1,"highlight_end":55},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item, Self::Item) -> Self::Item,","highlight_start":1,"highlight_end":56},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        let first = self.next()?;","highlight_start":1,"highlight_end":34},{"text":"        Some(self.fold(first, f))","highlight_start":1,"highlight_end":34},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Reduces the elements to a single one by repeatedly applying a reducing operation. If the","highlight_start":1,"highlight_end":97},{"text":"    /// closure returns a failure, the failure is propagated back to the caller immediately.","highlight_start":1,"highlight_end":93},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The return type of this method depends on the return type of the closure. If the closure","highlight_start":1,"highlight_end":97},{"text":"    /// returns `Result<Self::Item, E>`, then this function will return `Result<Option<Self::Item>,","highlight_start":1,"highlight_end":100},{"text":"    /// E>`. If the closure returns `Option<Self::Item>`, then this function will return","highlight_start":1,"highlight_end":89},{"text":"    /// `Option<Option<Self::Item>>`.","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// When called on an empty iterator, this function will return either `Some(None)` or","highlight_start":1,"highlight_end":91},{"text":"    /// `Ok(None)` depending on the type of the provided closure.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// For iterators with at least one element, this is essentially the same as calling","highlight_start":1,"highlight_end":89},{"text":"    /// [`try_fold()`] with the first element of the iterator as the initial accumulator value.","highlight_start":1,"highlight_end":96},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`try_fold()`]: Iterator::try_fold","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Safely calculate the sum of a series of numbers:","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iterator_try_reduce)]","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let numbers: Vec<usize> = vec![10, 20, 5, 23, 0];","highlight_start":1,"highlight_end":58},{"text":"    /// let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));","highlight_start":1,"highlight_end":75},{"text":"    /// assert_eq!(sum, Some(Some(58)));","highlight_start":1,"highlight_end":41},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Determine when a reduction short circuited:","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iterator_try_reduce)]","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let numbers = vec![1, 2, 3, usize::MAX, 4, 5];","highlight_start":1,"highlight_end":55},{"text":"    /// let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));","highlight_start":1,"highlight_end":75},{"text":"    /// assert_eq!(sum, None);","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Determine when a reduction was not performed because there are no elements:","highlight_start":1,"highlight_end":84},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iterator_try_reduce)]","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let numbers: Vec<usize> = Vec::new();","highlight_start":1,"highlight_end":46},{"text":"    /// let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));","highlight_start":1,"highlight_end":75},{"text":"    /// assert_eq!(sum, Some(None));","highlight_start":1,"highlight_end":37},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Use a [`Result`] instead of an [`Option`]:","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iterator_try_reduce)]","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let numbers = vec![\"1\", \"2\", \"3\", \"4\", \"5\"];","highlight_start":1,"highlight_end":53},{"text":"    /// let max: Result<Option<_>, <usize as std::str::FromStr>::Err> =","highlight_start":1,"highlight_end":72},{"text":"    ///     numbers.into_iter().try_reduce(|x, y| {","highlight_start":1,"highlight_end":52},{"text":"    ///         if x.parse::<usize>()? > y.parse::<usize>()? { Ok(x) } else { Ok(y) }","highlight_start":1,"highlight_end":86},{"text":"    ///     });","highlight_start":1,"highlight_end":16},{"text":"    /// assert_eq!(max, Ok(Some(\"5\")));","highlight_start":1,"highlight_end":40},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"iterator_try_reduce\", reason = \"new API\", issue = \"87053\")]","highlight_start":1,"highlight_end":86},{"text":"    fn try_reduce<F, R>(&mut self, f: F) -> ChangeOutputType<R, Option<R::Output>>","highlight_start":1,"highlight_end":83},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item, Self::Item) -> R,","highlight_start":1,"highlight_end":47},{"text":"        R: Try<Output = Self::Item>,","highlight_start":1,"highlight_end":37},{"text":"        R::Residual: Residual<Option<Self::Item>>,","highlight_start":1,"highlight_end":51},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        let first = match self.next() {","highlight_start":1,"highlight_end":40},{"text":"            Some(i) => i,","highlight_start":1,"highlight_end":26},{"text":"            None => return Try::from_output(None),","highlight_start":1,"highlight_end":51},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        match self.try_fold(first, f).branch() {","highlight_start":1,"highlight_end":49},{"text":"            ControlFlow::Break(r) => FromResidual::from_residual(r),","highlight_start":1,"highlight_end":69},{"text":"            ControlFlow::Continue(i) => Try::from_output(Some(i)),","highlight_start":1,"highlight_end":67},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Tests if every element of the iterator matches a predicate.","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `all()` takes a closure that returns `true` or `false`. It applies","highlight_start":1,"highlight_end":75},{"text":"    /// this closure to each element of the iterator, and if they all return","highlight_start":1,"highlight_end":77},{"text":"    /// `true`, then so does `all()`. If any of them return `false`, it","highlight_start":1,"highlight_end":72},{"text":"    /// returns `false`.","highlight_start":1,"highlight_end":25},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `all()` is short-circuiting; in other words, it will stop processing","highlight_start":1,"highlight_end":77},{"text":"    /// as soon as it finds a `false`, given that no matter what else happens,","highlight_start":1,"highlight_end":79},{"text":"    /// the result will also be `false`.","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// An empty iterator returns `true`.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!(a.iter().all(|&x| x > 0));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!(!a.iter().all(|&x| x > 2));","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Stopping at the first `false`:","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!(!iter.all(|&x| x != 2));","highlight_start":1,"highlight_end":41},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // we can still use `iter`, as there are more elements.","highlight_start":1,"highlight_end":64},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn all<F>(&mut self, f: F) -> bool","highlight_start":1,"highlight_end":39},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item) -> bool,","highlight_start":1,"highlight_end":38},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<()> {","highlight_start":1,"highlight_end":92},{"text":"            move |(), x| {","highlight_start":1,"highlight_end":27},{"text":"                if f(x) { ControlFlow::CONTINUE } else { ControlFlow::BREAK }","highlight_start":1,"highlight_end":78},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        self.try_fold((), check(f)) == ControlFlow::CONTINUE","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Tests if any element of the iterator matches a predicate.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `any()` takes a closure that returns `true` or `false`. It applies","highlight_start":1,"highlight_end":75},{"text":"    /// this closure to each element of the iterator, and if any of them return","highlight_start":1,"highlight_end":80},{"text":"    /// `true`, then so does `any()`. If they all return `false`, it","highlight_start":1,"highlight_end":69},{"text":"    /// returns `false`.","highlight_start":1,"highlight_end":25},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `any()` is short-circuiting; in other words, it will stop processing","highlight_start":1,"highlight_end":77},{"text":"    /// as soon as it finds a `true`, given that no matter what else happens,","highlight_start":1,"highlight_end":78},{"text":"    /// the result will also be `true`.","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// An empty iterator returns `false`.","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!(a.iter().any(|&x| x > 0));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!(!a.iter().any(|&x| x > 5));","highlight_start":1,"highlight_end":44},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Stopping at the first `true`:","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!(iter.any(|&x| x != 2));","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // we can still use `iter`, as there are more elements.","highlight_start":1,"highlight_end":64},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn any<F>(&mut self, f: F) -> bool","highlight_start":1,"highlight_end":39},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item) -> bool,","highlight_start":1,"highlight_end":38},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<()> {","highlight_start":1,"highlight_end":92},{"text":"            move |(), x| {","highlight_start":1,"highlight_end":27},{"text":"                if f(x) { ControlFlow::BREAK } else { ControlFlow::CONTINUE }","highlight_start":1,"highlight_end":78},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.try_fold((), check(f)) == ControlFlow::BREAK","highlight_start":1,"highlight_end":58},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Searches for an element of an iterator that satisfies a predicate.","highlight_start":1,"highlight_end":75},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `find()` takes a closure that returns `true` or `false`. It applies","highlight_start":1,"highlight_end":76},{"text":"    /// this closure to each element of the iterator, and if any of them return","highlight_start":1,"highlight_end":80},{"text":"    /// `true`, then `find()` returns [`Some(element)`]. If they all return","highlight_start":1,"highlight_end":76},{"text":"    /// `false`, it returns [`None`].","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `find()` is short-circuiting; in other words, it will stop processing","highlight_start":1,"highlight_end":78},{"text":"    /// as soon as the closure returns `true`.","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Because `find()` takes a reference, and many iterators iterate over","highlight_start":1,"highlight_end":76},{"text":"    /// references, this leads to a possibly confusing situation where the","highlight_start":1,"highlight_end":75},{"text":"    /// argument is a double reference. You can see this effect in the","highlight_start":1,"highlight_end":71},{"text":"    /// examples below, with `&&x`.","highlight_start":1,"highlight_end":36},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Some(element)`]: Some","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(a.iter().find(|&&x| x == 2), Some(&2));","highlight_start":1,"highlight_end":59},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(a.iter().find(|&&x| x == 5), None);","highlight_start":1,"highlight_end":55},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Stopping at the first `true`:","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.find(|&&x| x == 2), Some(&2));","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // we can still use `iter`, as there are more elements.","highlight_start":1,"highlight_end":64},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that `iter.find(f)` is equivalent to `iter.filter(f).next()`.","highlight_start":1,"highlight_end":75},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>","highlight_start":1,"highlight_end":62},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        P: FnMut(&Self::Item) -> bool,","highlight_start":1,"highlight_end":39},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut((), T) -> ControlFlow<T> {","highlight_start":1,"highlight_end":100},{"text":"            move |(), x| {","highlight_start":1,"highlight_end":27},{"text":"                if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::CONTINUE }","highlight_start":1,"highlight_end":90},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.try_fold((), check(predicate)).break_value()","highlight_start":1,"highlight_end":58},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Applies function to the elements of iterator and returns","highlight_start":1,"highlight_end":65},{"text":"    /// the first non-none result.","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [\"lol\", \"NaN\", \"2\", \"5\"];","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let first_number = a.iter().find_map(|s| s.parse().ok());","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(first_number, Some(2));","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iterator_find_map\", since = \"1.30.0\")]","highlight_start":1,"highlight_end":63},{"text":"    fn find_map<B, F>(&mut self, f: F) -> Option<B>","highlight_start":1,"highlight_end":52},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item) -> Option<B>,","highlight_start":1,"highlight_end":43},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut((), T) -> ControlFlow<B> {","highlight_start":1,"highlight_end":99},{"text":"            move |(), x| match f(x) {","highlight_start":1,"highlight_end":38},{"text":"                Some(x) => ControlFlow::Break(x),","highlight_start":1,"highlight_end":50},{"text":"                None => ControlFlow::CONTINUE,","highlight_start":1,"highlight_end":47},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.try_fold((), check(f)).break_value()","highlight_start":1,"highlight_end":50},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Applies function to the elements of iterator and returns","highlight_start":1,"highlight_end":65},{"text":"    /// the first true result or the first error.","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The return type of this method depends on the return type of the closure.","highlight_start":1,"highlight_end":82},{"text":"    /// If you return `Result<bool, E>` from the closure, you'll get a `Result<Option<Self::Item>; E>`.","highlight_start":1,"highlight_end":104},{"text":"    /// If you return `Option<bool>` from the closure, you'll get an `Option<Option<Self::Item>>`.","highlight_start":1,"highlight_end":99},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(try_find)]","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let a = [\"1\", \"2\", \"lol\", \"NaN\", \"5\"];","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let is_my_num = |s: &str, search: i32| -> Result<bool, std::num::ParseIntError> {","highlight_start":1,"highlight_end":90},{"text":"    ///     Ok(s.parse::<i32>()?  == search)","highlight_start":1,"highlight_end":45},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result = a.iter().try_find(|&&s| is_my_num(s, 2));","highlight_start":1,"highlight_end":63},{"text":"    /// assert_eq!(result, Ok(Some(&\"2\")));","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let result = a.iter().try_find(|&&s| is_my_num(s, 5));","highlight_start":1,"highlight_end":63},{"text":"    /// assert!(result.is_err());","highlight_start":1,"highlight_end":34},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This also supports other types which implement `Try`, not just `Result`.","highlight_start":1,"highlight_end":81},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(try_find)]","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// use std::num::NonZeroU32;","highlight_start":1,"highlight_end":34},{"text":"    /// let a = [3, 5, 7, 4, 9, 0, 11];","highlight_start":1,"highlight_end":40},{"text":"    /// let result = a.iter().try_find(|&&x| NonZeroU32::new(x).map(|y| y.is_power_of_two()));","highlight_start":1,"highlight_end":95},{"text":"    /// assert_eq!(result, Some(Some(&4)));","highlight_start":1,"highlight_end":44},{"text":"    /// let result = a.iter().take(3).try_find(|&&x| NonZeroU32::new(x).map(|y| y.is_power_of_two()));","highlight_start":1,"highlight_end":103},{"text":"    /// assert_eq!(result, Some(None));","highlight_start":1,"highlight_end":40},{"text":"    /// let result = a.iter().rev().try_find(|&&x| NonZeroU32::new(x).map(|y| y.is_power_of_two()));","highlight_start":1,"highlight_end":101},{"text":"    /// assert_eq!(result, None);","highlight_start":1,"highlight_end":34},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"try_find\", reason = \"new API\", issue = \"63178\")]","highlight_start":1,"highlight_end":75},{"text":"    fn try_find<F, R>(&mut self, f: F) -> ChangeOutputType<R, Option<Self::Item>>","highlight_start":1,"highlight_end":82},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(&Self::Item) -> R,","highlight_start":1,"highlight_end":36},{"text":"        R: Try<Output = bool>,","highlight_start":1,"highlight_end":31},{"text":"        R::Residual: Residual<Option<Self::Item>>,","highlight_start":1,"highlight_end":51},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn check<I, V, R>(","highlight_start":1,"highlight_end":27},{"text":"            mut f: impl FnMut(&I) -> V,","highlight_start":1,"highlight_end":40},{"text":"        ) -> impl FnMut((), I) -> ControlFlow<R::TryType>","highlight_start":1,"highlight_end":58},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            V: Try<Output = bool, Residual = R>,","highlight_start":1,"highlight_end":49},{"text":"            R: Residual<Option<I>>,","highlight_start":1,"highlight_end":36},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            move |(), x| match f(&x).branch() {","highlight_start":1,"highlight_end":48},{"text":"                ControlFlow::Continue(false) => ControlFlow::CONTINUE,","highlight_start":1,"highlight_end":71},{"text":"                ControlFlow::Continue(true) => ControlFlow::Break(Try::from_output(Some(x))),","highlight_start":1,"highlight_end":94},{"text":"                ControlFlow::Break(r) => ControlFlow::Break(FromResidual::from_residual(r)),","highlight_start":1,"highlight_end":93},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        match self.try_fold((), check(f)) {","highlight_start":1,"highlight_end":44},{"text":"            ControlFlow::Break(x) => x,","highlight_start":1,"highlight_end":40},{"text":"            ControlFlow::Continue(()) => Try::from_output(None),","highlight_start":1,"highlight_end":65},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Searches for an element in an iterator, returning its index.","highlight_start":1,"highlight_end":69},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `position()` takes a closure that returns `true` or `false`. It applies","highlight_start":1,"highlight_end":80},{"text":"    /// this closure to each element of the iterator, and if one of them","highlight_start":1,"highlight_end":73},{"text":"    /// returns `true`, then `position()` returns [`Some(index)`]. If all of","highlight_start":1,"highlight_end":77},{"text":"    /// them return `false`, it returns [`None`].","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `position()` is short-circuiting; in other words, it will stop","highlight_start":1,"highlight_end":71},{"text":"    /// processing as soon as it finds a `true`.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Overflow Behavior","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The method does no guarding against overflows, so if there are more","highlight_start":1,"highlight_end":76},{"text":"    /// than [`usize::MAX`] non-matching elements, it either produces the wrong","highlight_start":1,"highlight_end":80},{"text":"    /// result or panics. If debug assertions are enabled, a panic is","highlight_start":1,"highlight_end":70},{"text":"    /// guaranteed.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Panics","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This function might panic if the iterator has more than `usize::MAX`","highlight_start":1,"highlight_end":77},{"text":"    /// non-matching elements.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Some(index)`]: Some","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(a.iter().position(|&x| x == 2), Some(1));","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(a.iter().position(|&x| x == 5), None);","highlight_start":1,"highlight_end":58},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Stopping at the first `true`:","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3, 4];","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.position(|&x| x >= 2), Some(1));","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // we can still use `iter`, as there are more elements.","highlight_start":1,"highlight_end":64},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // The returned index depends on iterator state","highlight_start":1,"highlight_end":56},{"text":"    /// assert_eq!(iter.position(|&x| x == 4), Some(0));","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn position<P>(&mut self, predicate: P) -> Option<usize>","highlight_start":1,"highlight_end":61},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        P: FnMut(Self::Item) -> bool,","highlight_start":1,"highlight_end":38},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn check<T>(","highlight_start":1,"highlight_end":21},{"text":"            mut predicate: impl FnMut(T) -> bool,","highlight_start":1,"highlight_end":50},{"text":"        ) -> impl FnMut(usize, T) -> ControlFlow<usize, usize> {","highlight_start":1,"highlight_end":65},{"text":"            #[rustc_inherit_overflow_checks]","highlight_start":1,"highlight_end":45},{"text":"            move |i, x| {","highlight_start":1,"highlight_end":26},{"text":"                if predicate(x) { ControlFlow::Break(i) } else { ControlFlow::Continue(i + 1) }","highlight_start":1,"highlight_end":96},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.try_fold(0, check(predicate)).break_value()","highlight_start":1,"highlight_end":57},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Searches for an element in an iterator from the right, returning its","highlight_start":1,"highlight_end":77},{"text":"    /// index.","highlight_start":1,"highlight_end":15},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `rposition()` takes a closure that returns `true` or `false`. It applies","highlight_start":1,"highlight_end":81},{"text":"    /// this closure to each element of the iterator, starting from the end,","highlight_start":1,"highlight_end":77},{"text":"    /// and if one of them returns `true`, then `rposition()` returns","highlight_start":1,"highlight_end":70},{"text":"    /// [`Some(index)`]. If all of them return `false`, it returns [`None`].","highlight_start":1,"highlight_end":77},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `rposition()` is short-circuiting; in other words, it will stop","highlight_start":1,"highlight_end":72},{"text":"    /// processing as soon as it finds a `true`.","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Some(index)`]: Some","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(a.iter().rposition(|&x| x == 3), Some(2));","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(a.iter().rposition(|&x| x == 5), None);","highlight_start":1,"highlight_end":59},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Stopping at the first `true`:","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter();","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.rposition(|&x| x == 2), Some(1));","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // we can still use `iter`, as there are more elements.","highlight_start":1,"highlight_end":64},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn rposition<P>(&mut self, predicate: P) -> Option<usize>","highlight_start":1,"highlight_end":62},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        P: FnMut(Self::Item) -> bool,","highlight_start":1,"highlight_end":38},{"text":"        Self: Sized + ExactSizeIterator + DoubleEndedIterator,","highlight_start":1,"highlight_end":63},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        // No need for an overflow check here, because `ExactSizeIterator`","highlight_start":1,"highlight_end":75},{"text":"        // implies that the number of elements fits into a `usize`.","highlight_start":1,"highlight_end":68},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn check<T>(","highlight_start":1,"highlight_end":21},{"text":"            mut predicate: impl FnMut(T) -> bool,","highlight_start":1,"highlight_end":50},{"text":"        ) -> impl FnMut(usize, T) -> ControlFlow<usize, usize> {","highlight_start":1,"highlight_end":65},{"text":"            move |i, x| {","highlight_start":1,"highlight_end":26},{"text":"                let i = i - 1;","highlight_start":1,"highlight_end":31},{"text":"                if predicate(x) { ControlFlow::Break(i) } else { ControlFlow::Continue(i) }","highlight_start":1,"highlight_end":92},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let n = self.len();","highlight_start":1,"highlight_end":28},{"text":"        self.try_rfold(n, check(predicate)).break_value()","highlight_start":1,"highlight_end":58},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the maximum element of an iterator.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If several elements are equally maximum, the last element is","highlight_start":1,"highlight_end":69},{"text":"    /// returned. If the iterator is empty, [`None`] is returned.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that [`f32`]/[`f64`] doesn't implement [`Ord`] due to NaN being","highlight_start":1,"highlight_end":77},{"text":"    /// incomparable. You can work around this by using [`Iterator::reduce`]:","highlight_start":1,"highlight_end":78},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"    ///     [2.4, f32::NAN, 1.3]","highlight_start":1,"highlight_end":33},{"text":"    ///         .into_iter()","highlight_start":1,"highlight_end":29},{"text":"    ///         .reduce(f32::max)","highlight_start":1,"highlight_end":34},{"text":"    ///         .unwrap(),","highlight_start":1,"highlight_end":27},{"text":"    ///     2.4","highlight_start":1,"highlight_end":16},{"text":"    /// );","highlight_start":1,"highlight_end":11},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// let b: Vec<u32> = Vec::new();","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(a.iter().max(), Some(&3));","highlight_start":1,"highlight_end":46},{"text":"    /// assert_eq!(b.iter().max(), None);","highlight_start":1,"highlight_end":42},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn max(self) -> Option<Self::Item>","highlight_start":1,"highlight_end":39},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        Self::Item: Ord,","highlight_start":1,"highlight_end":25},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.max_by(Ord::cmp)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the minimum element of an iterator.","highlight_start":1,"highlight_end":52},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If several elements are equally minimum, the first element is returned.","highlight_start":1,"highlight_end":80},{"text":"    /// If the iterator is empty, [`None`] is returned.","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that [`f32`]/[`f64`] doesn't implement [`Ord`] due to NaN being","highlight_start":1,"highlight_end":77},{"text":"    /// incomparable. You can work around this by using [`Iterator::reduce`]:","highlight_start":1,"highlight_end":78},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"    ///     [2.4, f32::NAN, 1.3]","highlight_start":1,"highlight_end":33},{"text":"    ///         .into_iter()","highlight_start":1,"highlight_end":29},{"text":"    ///         .reduce(f32::min)","highlight_start":1,"highlight_end":34},{"text":"    ///         .unwrap(),","highlight_start":1,"highlight_end":27},{"text":"    ///     1.3","highlight_start":1,"highlight_end":16},{"text":"    /// );","highlight_start":1,"highlight_end":11},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// let b: Vec<u32> = Vec::new();","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(a.iter().min(), Some(&1));","highlight_start":1,"highlight_end":46},{"text":"    /// assert_eq!(b.iter().min(), None);","highlight_start":1,"highlight_end":42},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn min(self) -> Option<Self::Item>","highlight_start":1,"highlight_end":39},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        Self::Item: Ord,","highlight_start":1,"highlight_end":25},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.min_by(Ord::cmp)","highlight_start":1,"highlight_end":30},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the element that gives the maximum value from the","highlight_start":1,"highlight_end":66},{"text":"    /// specified function.","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If several elements are equally maximum, the last element is","highlight_start":1,"highlight_end":69},{"text":"    /// returned. If the iterator is empty, [`None`] is returned.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-3_i32, 0, 1, 5, -10];","highlight_start":1,"highlight_end":40},{"text":"    /// assert_eq!(*a.iter().max_by_key(|x| x.abs()).unwrap(), -10);","highlight_start":1,"highlight_end":69},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]","highlight_start":1,"highlight_end":60},{"text":"    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>","highlight_start":1,"highlight_end":63},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(&Self::Item) -> B,","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {","highlight_start":1,"highlight_end":78},{"text":"            move |x| (f(&x), x)","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn compare<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> Ordering {","highlight_start":1,"highlight_end":82},{"text":"            x_p.cmp(y_p)","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let (_, x) = self.map(key(f)).max_by(compare)?;","highlight_start":1,"highlight_end":56},{"text":"        Some(x)","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the element that gives the maximum value with respect to the","highlight_start":1,"highlight_end":77},{"text":"    /// specified comparison function.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If several elements are equally maximum, the last element is","highlight_start":1,"highlight_end":69},{"text":"    /// returned. If the iterator is empty, [`None`] is returned.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-3_i32, 0, 1, 5, -10];","highlight_start":1,"highlight_end":40},{"text":"    /// assert_eq!(*a.iter().max_by(|x, y| x.cmp(y)).unwrap(), 5);","highlight_start":1,"highlight_end":67},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iter_max_by\", since = \"1.15.0\")]","highlight_start":1,"highlight_end":57},{"text":"    fn max_by<F>(self, compare: F) -> Option<Self::Item>","highlight_start":1,"highlight_end":57},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(&Self::Item, &Self::Item) -> Ordering,","highlight_start":1,"highlight_end":56},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {","highlight_start":1,"highlight_end":91},{"text":"            move |x, y| cmp::max_by(x, y, &mut compare)","highlight_start":1,"highlight_end":56},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.reduce(fold(compare))","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the element that gives the minimum value from the","highlight_start":1,"highlight_end":66},{"text":"    /// specified function.","highlight_start":1,"highlight_end":28},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If several elements are equally minimum, the first element is","highlight_start":1,"highlight_end":70},{"text":"    /// returned. If the iterator is empty, [`None`] is returned.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-3_i32, 0, 1, 5, -10];","highlight_start":1,"highlight_end":40},{"text":"    /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);","highlight_start":1,"highlight_end":67},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]","highlight_start":1,"highlight_end":60},{"text":"    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>","highlight_start":1,"highlight_end":63},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(&Self::Item) -> B,","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {","highlight_start":1,"highlight_end":78},{"text":"            move |x| (f(&x), x)","highlight_start":1,"highlight_end":32},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn compare<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> Ordering {","highlight_start":1,"highlight_end":82},{"text":"            x_p.cmp(y_p)","highlight_start":1,"highlight_end":25},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let (_, x) = self.map(key(f)).min_by(compare)?;","highlight_start":1,"highlight_end":56},{"text":"        Some(x)","highlight_start":1,"highlight_end":16},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Returns the element that gives the minimum value with respect to the","highlight_start":1,"highlight_end":77},{"text":"    /// specified comparison function.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If several elements are equally minimum, the first element is","highlight_start":1,"highlight_end":70},{"text":"    /// returned. If the iterator is empty, [`None`] is returned.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [-3_i32, 0, 1, 5, -10];","highlight_start":1,"highlight_end":40},{"text":"    /// assert_eq!(*a.iter().min_by(|x, y| x.cmp(y)).unwrap(), -10);","highlight_start":1,"highlight_end":69},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[stable(feature = \"iter_min_by\", since = \"1.15.0\")]","highlight_start":1,"highlight_end":57},{"text":"    fn min_by<F>(self, compare: F) -> Option<Self::Item>","highlight_start":1,"highlight_end":57},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(&Self::Item, &Self::Item) -> Ordering,","highlight_start":1,"highlight_end":56},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {","highlight_start":1,"highlight_end":91},{"text":"            move |x, y| cmp::min_by(x, y, &mut compare)","highlight_start":1,"highlight_end":56},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.reduce(fold(compare))","highlight_start":1,"highlight_end":35},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Reverses an iterator's direction.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Usually, iterators iterate from left to right. After using `rev()`,","highlight_start":1,"highlight_end":76},{"text":"    /// an iterator will instead iterate from right to left.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This is only possible if the iterator has an end, so `rev()` only","highlight_start":1,"highlight_end":74},{"text":"    /// works on [`DoubleEndedIterator`]s.","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut iter = a.iter().rev();","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), Some(&3));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&2));","highlight_start":1,"highlight_end":43},{"text":"    /// assert_eq!(iter.next(), Some(&1));","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(iter.next(), None);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[doc(alias = \"reverse\")]","highlight_start":1,"highlight_end":30},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn rev(self) -> Rev<Self>","highlight_start":1,"highlight_end":30},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized + DoubleEndedIterator,","highlight_start":1,"highlight_end":43},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Rev::new(self)","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Converts an iterator of pairs into a pair of containers.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// `unzip()` consumes an entire iterator of pairs, producing two","highlight_start":1,"highlight_end":70},{"text":"    /// collections: one from the left elements of the pairs, and one","highlight_start":1,"highlight_end":70},{"text":"    /// from the right elements.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This function is, in some sense, the opposite of [`zip`].","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`zip`]: Iterator::zip","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [(1, 2), (3, 4), (5, 6)];","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let (left, right): (Vec<_>, Vec<_>) = a.iter().cloned().unzip();","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(left, [1, 3, 5]);","highlight_start":1,"highlight_end":37},{"text":"    /// assert_eq!(right, [2, 4, 6]);","highlight_start":1,"highlight_end":38},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // you can also unzip multiple nested tuples at once","highlight_start":1,"highlight_end":61},{"text":"    /// let a = [(1, (2, 3)), (4, (5, 6))];","highlight_start":1,"highlight_end":44},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let (x, (y, z)): (Vec<_>, (Vec<_>, Vec<_>)) = a.iter().cloned().unzip();","highlight_start":1,"highlight_end":81},{"text":"    /// assert_eq!(x, [1, 4]);","highlight_start":1,"highlight_end":31},{"text":"    /// assert_eq!(y, [2, 5]);","highlight_start":1,"highlight_end":31},{"text":"    /// assert_eq!(z, [3, 6]);","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn unzip<A, B, FromA, FromB>(self) -> (FromA, FromB)","highlight_start":1,"highlight_end":57},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        FromA: Default + Extend<A>,","highlight_start":1,"highlight_end":36},{"text":"        FromB: Default + Extend<B>,","highlight_start":1,"highlight_end":36},{"text":"        Self: Sized + Iterator<Item = (A, B)>,","highlight_start":1,"highlight_end":47},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        let mut unzipped: (FromA, FromB) = Default::default();","highlight_start":1,"highlight_end":63},{"text":"        unzipped.extend(self);","highlight_start":1,"highlight_end":31},{"text":"        unzipped","highlight_start":1,"highlight_end":17},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator which copies all of its elements.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This is useful when you have an iterator over `&T`, but you need an","highlight_start":1,"highlight_end":76},{"text":"    /// iterator over `T`.","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let v_copied: Vec<_> = a.iter().copied().collect();","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // copied is the same as .map(|&x| x)","highlight_start":1,"highlight_end":46},{"text":"    /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(v_copied, vec![1, 2, 3]);","highlight_start":1,"highlight_end":45},{"text":"    /// assert_eq!(v_map, vec![1, 2, 3]);","highlight_start":1,"highlight_end":42},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_copied\", since = \"1.36.0\")]","highlight_start":1,"highlight_end":57},{"text":"    fn copied<'a, T: 'a>(self) -> Copied<Self>","highlight_start":1,"highlight_end":47},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized + Iterator<Item = &'a T>,","highlight_start":1,"highlight_end":46},{"text":"        T: Copy,","highlight_start":1,"highlight_end":17},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Copied::new(self)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Creates an iterator which [`clone`]s all of its elements.","highlight_start":1,"highlight_end":66},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This is useful when you have an iterator over `&T`, but you need an","highlight_start":1,"highlight_end":76},{"text":"    /// iterator over `T`.","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// There is no guarantee whatsoever about the `clone` method actually","highlight_start":1,"highlight_end":75},{"text":"    /// being called *or* optimized away. So code should not depend on","highlight_start":1,"highlight_end":71},{"text":"    /// either.","highlight_start":1,"highlight_end":16},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`clone`]: Clone::clone","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let v_cloned: Vec<_> = a.iter().cloned().collect();","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // cloned is the same as .map(|&x| x), for integers","highlight_start":1,"highlight_end":60},{"text":"    /// let v_map: Vec<_> = a.iter().map(|&x| x).collect();","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(v_cloned, vec![1, 2, 3]);","highlight_start":1,"highlight_end":45},{"text":"    /// assert_eq!(v_map, vec![1, 2, 3]);","highlight_start":1,"highlight_end":42},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// To get the best performance, try to clone late:","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [vec![0_u8, 1, 2], vec![3, 4], vec![23]];","highlight_start":1,"highlight_end":58},{"text":"    /// // don't do this:","highlight_start":1,"highlight_end":26},{"text":"    /// let slower: Vec<_> = a.iter().cloned().filter(|s| s.len() == 1).collect();","highlight_start":1,"highlight_end":83},{"text":"    /// assert_eq!(&[vec![23]], &slower[..]);","highlight_start":1,"highlight_end":46},{"text":"    /// // instead call `cloned` late","highlight_start":1,"highlight_end":38},{"text":"    /// let faster: Vec<_> = a.iter().filter(|s| s.len() == 1).cloned().collect();","highlight_start":1,"highlight_end":83},{"text":"    /// assert_eq!(&[vec![23]], &faster[..]);","highlight_start":1,"highlight_end":46},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    fn cloned<'a, T: 'a>(self) -> Cloned<Self>","highlight_start":1,"highlight_end":47},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized + Iterator<Item = &'a T>,","highlight_start":1,"highlight_end":46},{"text":"        T: Clone,","highlight_start":1,"highlight_end":18},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Cloned::new(self)","highlight_start":1,"highlight_end":26},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Repeats an iterator endlessly.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Instead of stopping at [`None`], the iterator will instead start again,","highlight_start":1,"highlight_end":80},{"text":"    /// from the beginning. After iterating again, it will start at the","highlight_start":1,"highlight_end":72},{"text":"    /// beginning again. And again. And again. Forever. Note that in case the","highlight_start":1,"highlight_end":78},{"text":"    /// original iterator is empty, the resulting iterator will also be empty.","highlight_start":1,"highlight_end":79},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let mut it = a.iter().cycle();","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(it.next(), Some(&1));","highlight_start":1,"highlight_end":41},{"text":"    /// assert_eq!(it.next(), Some(&2));","highlight_start":1,"highlight_end":41},{"text":"    /// assert_eq!(it.next(), Some(&3));","highlight_start":1,"highlight_end":41},{"text":"    /// assert_eq!(it.next(), Some(&1));","highlight_start":1,"highlight_end":41},{"text":"    /// assert_eq!(it.next(), Some(&2));","highlight_start":1,"highlight_end":41},{"text":"    /// assert_eq!(it.next(), Some(&3));","highlight_start":1,"highlight_end":41},{"text":"    /// assert_eq!(it.next(), Some(&1));","highlight_start":1,"highlight_end":41},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"rust1\", since = \"1.0.0\")]","highlight_start":1,"highlight_end":50},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    fn cycle(self) -> Cycle<Self>","highlight_start":1,"highlight_end":34},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized + Clone,","highlight_start":1,"highlight_end":29},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Cycle::new(self)","highlight_start":1,"highlight_end":25},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Sums the elements of an iterator.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Takes each element, adds them together, and returns the result.","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// An empty iterator returns the zero value of the type.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Panics","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// When calling `sum()` and a primitive integer type is being returned, this","highlight_start":1,"highlight_end":82},{"text":"    /// method will panic if the computation overflows and debug assertions are","highlight_start":1,"highlight_end":80},{"text":"    /// enabled.","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// let a = [1, 2, 3];","highlight_start":1,"highlight_end":27},{"text":"    /// let sum: i32 = a.iter().sum();","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(sum, 6);","highlight_start":1,"highlight_end":28},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_arith\", since = \"1.11.0\")]","highlight_start":1,"highlight_end":56},{"text":"    fn sum<S>(self) -> S","highlight_start":1,"highlight_end":25},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        S: Sum<Self::Item>,","highlight_start":1,"highlight_end":28},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Sum::sum(self)","highlight_start":1,"highlight_end":23},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Iterates over the entire iterator, multiplying all the elements","highlight_start":1,"highlight_end":72},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// An empty iterator returns the one value of the type.","highlight_start":1,"highlight_end":61},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Panics","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// When calling `product()` and a primitive integer type is being returned,","highlight_start":1,"highlight_end":81},{"text":"    /// method will panic if the computation overflows and debug assertions are","highlight_start":1,"highlight_end":80},{"text":"    /// enabled.","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// fn factorial(n: u32) -> u32 {","highlight_start":1,"highlight_end":38},{"text":"    ///     (1..=n).product()","highlight_start":1,"highlight_end":30},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// assert_eq!(factorial(0), 1);","highlight_start":1,"highlight_end":37},{"text":"    /// assert_eq!(factorial(1), 1);","highlight_start":1,"highlight_end":37},{"text":"    /// assert_eq!(factorial(5), 120);","highlight_start":1,"highlight_end":39},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_arith\", since = \"1.11.0\")]","highlight_start":1,"highlight_end":56},{"text":"    fn product<P>(self) -> P","highlight_start":1,"highlight_end":29},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        P: Product<Self::Item>,","highlight_start":1,"highlight_end":32},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        Product::product(self)","highlight_start":1,"highlight_end":31},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [Lexicographically](Ord#lexicographical-comparison) compares the elements of this [`Iterator`] with those","highlight_start":1,"highlight_end":114},{"text":"    /// of another.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use std::cmp::Ordering;","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!([1].iter().cmp([1].iter()), Ordering::Equal);","highlight_start":1,"highlight_end":65},{"text":"    /// assert_eq!([1].iter().cmp([1, 2].iter()), Ordering::Less);","highlight_start":1,"highlight_end":67},{"text":"    /// assert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);","highlight_start":1,"highlight_end":70},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_order\", since = \"1.5.0\")]","highlight_start":1,"highlight_end":55},{"text":"    fn cmp<I>(self, other: I) -> Ordering","highlight_start":1,"highlight_end":42},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        I: IntoIterator<Item = Self::Item>,","highlight_start":1,"highlight_end":44},{"text":"        Self::Item: Ord,","highlight_start":1,"highlight_end":25},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.cmp_by(other, |x, y| x.cmp(&y))","highlight_start":1,"highlight_end":45},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [Lexicographically](Ord#lexicographical-comparison) compares the elements of this [`Iterator`] with those","highlight_start":1,"highlight_end":114},{"text":"    /// of another with respect to the specified comparison function.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_order_by)]","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// use std::cmp::Ordering;","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let xs = [1, 2, 3, 4];","highlight_start":1,"highlight_end":31},{"text":"    /// let ys = [1, 4, 9, 16];","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| x.cmp(&y)), Ordering::Less);","highlight_start":1,"highlight_end":79},{"text":"    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (x * x).cmp(&y)), Ordering::Equal);","highlight_start":1,"highlight_end":86},{"text":"    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (2 * x).cmp(&y)), Ordering::Greater);","highlight_start":1,"highlight_end":88},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[unstable(feature = \"iter_order_by\", issue = \"64295\")]","highlight_start":1,"highlight_end":60},{"text":"    fn cmp_by<I, F>(mut self, other: I, mut cmp: F) -> Ordering","highlight_start":1,"highlight_end":64},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        F: FnMut(Self::Item, I::Item) -> Ordering,","highlight_start":1,"highlight_end":51},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        let mut other = other.into_iter();","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        loop {","highlight_start":1,"highlight_end":15},{"text":"            let x = match self.next() {","highlight_start":1,"highlight_end":40},{"text":"                None => {","highlight_start":1,"highlight_end":26},{"text":"                    if other.next().is_none() {","highlight_start":1,"highlight_end":48},{"text":"                        return Ordering::Equal;","highlight_start":1,"highlight_end":48},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        return Ordering::Less;","highlight_start":1,"highlight_end":47},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Some(val) => val,","highlight_start":1,"highlight_end":34},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let y = match other.next() {","highlight_start":1,"highlight_end":41},{"text":"                None => return Ordering::Greater,","highlight_start":1,"highlight_end":50},{"text":"                Some(val) => val,","highlight_start":1,"highlight_end":34},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            match cmp(x, y) {","highlight_start":1,"highlight_end":30},{"text":"                Ordering::Equal => (),","highlight_start":1,"highlight_end":39},{"text":"                non_eq => return non_eq,","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [Lexicographically](Ord#lexicographical-comparison) compares the elements of this [`Iterator`] with those","highlight_start":1,"highlight_end":114},{"text":"    /// of another.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use std::cmp::Ordering;","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));","highlight_start":1,"highlight_end":81},{"text":"    /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));","highlight_start":1,"highlight_end":84},{"text":"    /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));","highlight_start":1,"highlight_end":87},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!([f64::NAN].iter().partial_cmp([1.].iter()), None);","highlight_start":1,"highlight_end":70},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_order\", since = \"1.5.0\")]","highlight_start":1,"highlight_end":55},{"text":"    fn partial_cmp<I>(self, other: I) -> Option<Ordering>","highlight_start":1,"highlight_end":58},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        Self::Item: PartialOrd<I::Item>,","highlight_start":1,"highlight_end":41},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.partial_cmp_by(other, |x, y| x.partial_cmp(&y))","highlight_start":1,"highlight_end":61},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// [Lexicographically](Ord#lexicographical-comparison) compares the elements of this [`Iterator`] with those","highlight_start":1,"highlight_end":114},{"text":"    /// of another with respect to the specified comparison function.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_order_by)]","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// use std::cmp::Ordering;","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let xs = [1.0, 2.0, 3.0, 4.0];","highlight_start":1,"highlight_end":39},{"text":"    /// let ys = [1.0, 4.0, 9.0, 16.0];","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| x.partial_cmp(&y)),","highlight_start":1,"highlight_end":71},{"text":"    ///     Some(Ordering::Less)","highlight_start":1,"highlight_end":33},{"text":"    /// );","highlight_start":1,"highlight_end":11},{"text":"    /// assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (x * x).partial_cmp(&y)),","highlight_start":1,"highlight_end":77},{"text":"    ///     Some(Ordering::Equal)","highlight_start":1,"highlight_end":34},{"text":"    /// );","highlight_start":1,"highlight_end":11},{"text":"    /// assert_eq!(","highlight_start":1,"highlight_end":20},{"text":"    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (2.0 * x).partial_cmp(&y)),","highlight_start":1,"highlight_end":79},{"text":"    ///     Some(Ordering::Greater)","highlight_start":1,"highlight_end":36},{"text":"    /// );","highlight_start":1,"highlight_end":11},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[unstable(feature = \"iter_order_by\", issue = \"64295\")]","highlight_start":1,"highlight_end":60},{"text":"    fn partial_cmp_by<I, F>(mut self, other: I, mut partial_cmp: F) -> Option<Ordering>","highlight_start":1,"highlight_end":88},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        F: FnMut(Self::Item, I::Item) -> Option<Ordering>,","highlight_start":1,"highlight_end":59},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        let mut other = other.into_iter();","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        loop {","highlight_start":1,"highlight_end":15},{"text":"            let x = match self.next() {","highlight_start":1,"highlight_end":40},{"text":"                None => {","highlight_start":1,"highlight_end":26},{"text":"                    if other.next().is_none() {","highlight_start":1,"highlight_end":48},{"text":"                        return Some(Ordering::Equal);","highlight_start":1,"highlight_end":54},{"text":"                    } else {","highlight_start":1,"highlight_end":29},{"text":"                        return Some(Ordering::Less);","highlight_start":1,"highlight_end":53},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Some(val) => val,","highlight_start":1,"highlight_end":34},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let y = match other.next() {","highlight_start":1,"highlight_end":41},{"text":"                None => return Some(Ordering::Greater),","highlight_start":1,"highlight_end":56},{"text":"                Some(val) => val,","highlight_start":1,"highlight_end":34},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            match partial_cmp(x, y) {","highlight_start":1,"highlight_end":38},{"text":"                Some(Ordering::Equal) => (),","highlight_start":1,"highlight_end":45},{"text":"                non_eq => return non_eq,","highlight_start":1,"highlight_end":41},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determines if the elements of this [`Iterator`] are equal to those of","highlight_start":1,"highlight_end":78},{"text":"    /// another.","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!([1].iter().eq([1].iter()), true);","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!([1].iter().eq([1, 2].iter()), false);","highlight_start":1,"highlight_end":57},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_order\", since = \"1.5.0\")]","highlight_start":1,"highlight_end":55},{"text":"    fn eq<I>(self, other: I) -> bool","highlight_start":1,"highlight_end":37},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        Self::Item: PartialEq<I::Item>,","highlight_start":1,"highlight_end":40},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.eq_by(other, |x, y| x == y)","highlight_start":1,"highlight_end":41},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determines if the elements of this [`Iterator`] are equal to those of","highlight_start":1,"highlight_end":78},{"text":"    /// another with respect to the specified equality function.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Basic usage:","highlight_start":1,"highlight_end":21},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(iter_order_by)]","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// let xs = [1, 2, 3, 4];","highlight_start":1,"highlight_end":31},{"text":"    /// let ys = [1, 4, 9, 16];","highlight_start":1,"highlight_end":32},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!(xs.iter().eq_by(&ys, |&x, &y| x * x == y));","highlight_start":1,"highlight_end":60},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[unstable(feature = \"iter_order_by\", issue = \"64295\")]","highlight_start":1,"highlight_end":60},{"text":"    fn eq_by<I, F>(mut self, other: I, mut eq: F) -> bool","highlight_start":1,"highlight_end":58},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        F: FnMut(Self::Item, I::Item) -> bool,","highlight_start":1,"highlight_end":47},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        let mut other = other.into_iter();","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        loop {","highlight_start":1,"highlight_end":15},{"text":"            let x = match self.next() {","highlight_start":1,"highlight_end":40},{"text":"                None => return other.next().is_none(),","highlight_start":1,"highlight_end":55},{"text":"                Some(val) => val,","highlight_start":1,"highlight_end":34},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let y = match other.next() {","highlight_start":1,"highlight_end":41},{"text":"                None => return false,","highlight_start":1,"highlight_end":38},{"text":"                Some(val) => val,","highlight_start":1,"highlight_end":34},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            if !eq(x, y) {","highlight_start":1,"highlight_end":27},{"text":"                return false;","highlight_start":1,"highlight_end":30},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determines if the elements of this [`Iterator`] are unequal to those of","highlight_start":1,"highlight_end":80},{"text":"    /// another.","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!([1].iter().ne([1].iter()), false);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!([1].iter().ne([1, 2].iter()), true);","highlight_start":1,"highlight_end":56},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_order\", since = \"1.5.0\")]","highlight_start":1,"highlight_end":55},{"text":"    fn ne<I>(self, other: I) -> bool","highlight_start":1,"highlight_end":37},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        Self::Item: PartialEq<I::Item>,","highlight_start":1,"highlight_end":40},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        !self.eq(other)","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determines if the elements of this [`Iterator`] are [lexicographically](Ord#lexicographical-comparison)","highlight_start":1,"highlight_end":112},{"text":"    /// less than those of another.","highlight_start":1,"highlight_end":36},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!([1].iter().lt([1].iter()), false);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!([1].iter().lt([1, 2].iter()), true);","highlight_start":1,"highlight_end":56},{"text":"    /// assert_eq!([1, 2].iter().lt([1].iter()), false);","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!([1, 2].iter().lt([1, 2].iter()), false);","highlight_start":1,"highlight_end":60},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_order\", since = \"1.5.0\")]","highlight_start":1,"highlight_end":55},{"text":"    fn lt<I>(self, other: I) -> bool","highlight_start":1,"highlight_end":37},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        Self::Item: PartialOrd<I::Item>,","highlight_start":1,"highlight_end":41},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.partial_cmp(other) == Some(Ordering::Less)","highlight_start":1,"highlight_end":56},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determines if the elements of this [`Iterator`] are [lexicographically](Ord#lexicographical-comparison)","highlight_start":1,"highlight_end":112},{"text":"    /// less or equal to those of another.","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!([1].iter().le([1].iter()), true);","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!([1].iter().le([1, 2].iter()), true);","highlight_start":1,"highlight_end":56},{"text":"    /// assert_eq!([1, 2].iter().le([1].iter()), false);","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!([1, 2].iter().le([1, 2].iter()), true);","highlight_start":1,"highlight_end":59},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_order\", since = \"1.5.0\")]","highlight_start":1,"highlight_end":55},{"text":"    fn le<I>(self, other: I) -> bool","highlight_start":1,"highlight_end":37},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        Self::Item: PartialOrd<I::Item>,","highlight_start":1,"highlight_end":41},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        matches!(self.partial_cmp(other), Some(Ordering::Less | Ordering::Equal))","highlight_start":1,"highlight_end":82},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determines if the elements of this [`Iterator`] are [lexicographically](Ord#lexicographical-comparison)","highlight_start":1,"highlight_end":112},{"text":"    /// greater than those of another.","highlight_start":1,"highlight_end":39},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!([1].iter().gt([1].iter()), false);","highlight_start":1,"highlight_end":54},{"text":"    /// assert_eq!([1].iter().gt([1, 2].iter()), false);","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!([1, 2].iter().gt([1].iter()), true);","highlight_start":1,"highlight_end":56},{"text":"    /// assert_eq!([1, 2].iter().gt([1, 2].iter()), false);","highlight_start":1,"highlight_end":60},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_order\", since = \"1.5.0\")]","highlight_start":1,"highlight_end":55},{"text":"    fn gt<I>(self, other: I) -> bool","highlight_start":1,"highlight_end":37},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        Self::Item: PartialOrd<I::Item>,","highlight_start":1,"highlight_end":41},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.partial_cmp(other) == Some(Ordering::Greater)","highlight_start":1,"highlight_end":59},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Determines if the elements of this [`Iterator`] are [lexicographically](Ord#lexicographical-comparison)","highlight_start":1,"highlight_end":112},{"text":"    /// greater than or equal to those of another.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// assert_eq!([1].iter().ge([1].iter()), true);","highlight_start":1,"highlight_end":53},{"text":"    /// assert_eq!([1].iter().ge([1, 2].iter()), false);","highlight_start":1,"highlight_end":57},{"text":"    /// assert_eq!([1, 2].iter().ge([1].iter()), true);","highlight_start":1,"highlight_end":56},{"text":"    /// assert_eq!([1, 2].iter().ge([1, 2].iter()), true);","highlight_start":1,"highlight_end":59},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[stable(feature = \"iter_order\", since = \"1.5.0\")]","highlight_start":1,"highlight_end":55},{"text":"    fn ge<I>(self, other: I) -> bool","highlight_start":1,"highlight_end":37},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        I: IntoIterator,","highlight_start":1,"highlight_end":25},{"text":"        Self::Item: PartialOrd<I::Item>,","highlight_start":1,"highlight_end":41},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        matches!(self.partial_cmp(other), Some(Ordering::Greater | Ordering::Equal))","highlight_start":1,"highlight_end":85},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if the elements of this iterator are sorted.","highlight_start":1,"highlight_end":60},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the","highlight_start":1,"highlight_end":96},{"text":"    /// iterator yields exactly zero or one element, `true` is returned.","highlight_start":1,"highlight_end":73},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition","highlight_start":1,"highlight_end":92},{"text":"    /// implies that this function returns `false` if any two consecutive items are not","highlight_start":1,"highlight_end":88},{"text":"    /// comparable.","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(is_sorted)]","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!([1, 2, 2, 9].iter().is_sorted());","highlight_start":1,"highlight_end":50},{"text":"    /// assert!(![1, 3, 2, 4].iter().is_sorted());","highlight_start":1,"highlight_end":51},{"text":"    /// assert!([0].iter().is_sorted());","highlight_start":1,"highlight_end":41},{"text":"    /// assert!(std::iter::empty::<i32>().is_sorted());","highlight_start":1,"highlight_end":56},{"text":"    /// assert!(![0.0, 1.0, f32::NAN].iter().is_sorted());","highlight_start":1,"highlight_end":59},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]","highlight_start":1,"highlight_end":76},{"text":"    fn is_sorted(self) -> bool","highlight_start":1,"highlight_end":31},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        Self::Item: PartialOrd,","highlight_start":1,"highlight_end":32},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.is_sorted_by(PartialOrd::partial_cmp)","highlight_start":1,"highlight_end":51},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if the elements of this iterator are sorted using the given comparator function.","highlight_start":1,"highlight_end":96},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Instead of using `PartialOrd::partial_cmp`, this function uses the given `compare`","highlight_start":1,"highlight_end":91},{"text":"    /// function to determine the ordering of two elements. Apart from that, it's equivalent to","highlight_start":1,"highlight_end":96},{"text":"    /// [`is_sorted`]; see its documentation for more information.","highlight_start":1,"highlight_end":67},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(is_sorted)]","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!([1, 2, 2, 9].iter().is_sorted_by(|a, b| a.partial_cmp(b)));","highlight_start":1,"highlight_end":76},{"text":"    /// assert!(![1, 3, 2, 4].iter().is_sorted_by(|a, b| a.partial_cmp(b)));","highlight_start":1,"highlight_end":77},{"text":"    /// assert!([0].iter().is_sorted_by(|a, b| a.partial_cmp(b)));","highlight_start":1,"highlight_end":67},{"text":"    /// assert!(std::iter::empty::<i32>().is_sorted_by(|a, b| a.partial_cmp(b)));","highlight_start":1,"highlight_end":82},{"text":"    /// assert!(![0.0, 1.0, f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));","highlight_start":1,"highlight_end":85},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`is_sorted`]: Iterator::is_sorted","highlight_start":1,"highlight_end":43},{"text":"    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]","highlight_start":1,"highlight_end":76},{"text":"    fn is_sorted_by<F>(mut self, compare: F) -> bool","highlight_start":1,"highlight_end":53},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>,","highlight_start":1,"highlight_end":64},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        #[inline]","highlight_start":1,"highlight_end":18},{"text":"        fn check<'a, T>(","highlight_start":1,"highlight_end":25},{"text":"            last: &'a mut T,","highlight_start":1,"highlight_end":29},{"text":"            mut compare: impl FnMut(&T, &T) -> Option<Ordering> + 'a,","highlight_start":1,"highlight_end":70},{"text":"        ) -> impl FnMut(T) -> bool + 'a {","highlight_start":1,"highlight_end":42},{"text":"            move |curr| {","highlight_start":1,"highlight_end":26},{"text":"                if let Some(Ordering::Greater) | None = compare(&last, &curr) {","highlight_start":1,"highlight_end":80},{"text":"                    return false;","highlight_start":1,"highlight_end":34},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                *last = curr;","highlight_start":1,"highlight_end":30},{"text":"                true","highlight_start":1,"highlight_end":21},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut last = match self.next() {","highlight_start":1,"highlight_end":43},{"text":"            Some(e) => e,","highlight_start":1,"highlight_end":26},{"text":"            None => return true,","highlight_start":1,"highlight_end":33},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        self.all(check(&mut last, compare))","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// Checks if the elements of this iterator are sorted using the given key extraction","highlight_start":1,"highlight_end":90},{"text":"    /// function.","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Instead of comparing the iterator's elements directly, this function compares the keys of","highlight_start":1,"highlight_end":98},{"text":"    /// the elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see","highlight_start":1,"highlight_end":99},{"text":"    /// its documentation for more information.","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`is_sorted`]: Iterator::is_sorted","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Examples","highlight_start":1,"highlight_end":19},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// #![feature(is_sorted)]","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// assert!([\"c\", \"bb\", \"aaa\"].iter().is_sorted_by_key(|s| s.len()));","highlight_start":1,"highlight_end":74},{"text":"    /// assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));","highlight_start":1,"highlight_end":74},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]","highlight_start":1,"highlight_end":76},{"text":"    fn is_sorted_by_key<F, K>(self, f: F) -> bool","highlight_start":1,"highlight_end":50},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: Sized,","highlight_start":1,"highlight_end":21},{"text":"        F: FnMut(Self::Item) -> K,","highlight_start":1,"highlight_end":35},{"text":"        K: PartialOrd,","highlight_start":1,"highlight_end":23},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        self.map(f).is_sorted()","highlight_start":1,"highlight_end":32},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    /// See [TrustedRandomAccess][super::super::TrustedRandomAccess]","highlight_start":1,"highlight_end":69},{"text":"    // The unusual name is to avoid name collisions in method resolution","highlight_start":1,"highlight_end":73},{"text":"    // see #76479.","highlight_start":1,"highlight_end":19},{"text":"    #[inline]","highlight_start":1,"highlight_end":14},{"text":"    #[doc(hidden)]","highlight_start":1,"highlight_end":19},{"text":"    #[unstable(feature = \"trusted_random_access\", issue = \"none\")]","highlight_start":1,"highlight_end":67},{"text":"    unsafe fn __iterator_get_unchecked(&mut self, _idx: usize) -> Self::Item","highlight_start":1,"highlight_end":77},{"text":"    where","highlight_start":1,"highlight_end":10},{"text":"        Self: TrustedRandomAccessNoCoerce,","highlight_start":1,"highlight_end":43},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        unreachable!(\"Always specialized\");","highlight_start":1,"highlight_end":44},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `FilteredProtocol` is not an iterator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\network_handle.rs:461:45\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m461\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                for ft in FilteredProtocol::into_iter(){\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`FilteredProtocol` is not an iterator\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m::: \u001b[0m\u001b[0msrc\\packet_handle.rs:235:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m235\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub enum FilteredProtocol {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m-------------------------\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mvariant or associated item `into_iter` not found here\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mdoesn't satisfy `FilteredProtocol: IntoIterator`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mdoesn't satisfy `FilteredProtocol: Iterator`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m             `FilteredProtocol: Iterator`\u001b[0m\n\u001b[0m             which is required by `FilteredProtocol: IntoIterator`\u001b[0m\n\u001b[0m             `&FilteredProtocol: Iterator`\u001b[0m\n\u001b[0m             which is required by `&FilteredProtocol: IntoIterator`\u001b[0m\n\u001b[0m             `&mut FilteredProtocol: Iterator`\u001b[0m\n\u001b[0m             which is required by `&mut FilteredProtocol: IntoIterator`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the following trait must be implemented\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mC:\\Users\\patri\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\core\\src\\iter\\traits\\iterator.rs:66:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m66\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Iterator {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m67\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// The type of the elements being iterated over.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m68\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[stable(feature = \"rust1\", since = \"1.0.0\")]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m69\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type Item;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3773\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3774\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\n"}
{"message":"unused import: `Write`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\packet_handle.rs","byte_start":584,"byte_end":589,"line_start":17,"line_end":17,"column_start":21,"column_end":26,"is_primary":true,"text":[{"text":"use std::io::{self, Write};","highlight_start":21,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `Write`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\packet_handle.rs:17:21\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::io::{self, Write};\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^\u001b[0m\n\n"}
{"message":"aborting due to previous error; 6 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to previous error; 6 warnings emitted\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0599`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about this error, try `rustc --explain E0599`.\u001b[0m\n"}
